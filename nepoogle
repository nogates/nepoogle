#!/usr/bin/env python2
# -*- coding: utf-8 -*-

#***************************************************************************
#*   nepoogle - a Nepomuk's search engine inspired in Google search syntax *
#*                                                                         *
#*   Copyright                                                             *
#*   (C) 2011,12 Ignacio Serantes <kde@aynoa.net>                          *
#*                                                                         *
#*   This program is free software; you can redistribute it and/or modify  *
#*   it under the terms of the GNU General Public License as published by  *
#*   the Free Software Foundation; either version 2 of the License, or     *
#*   (at your option) any later version.                                   *
#*                                                                         *
#*   This program is distributed in the hope that it will be useful,       *
#*   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
#*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
#*   GNU General Public License for more details.                          *
#*                                                                         *
#*   You should have received a copy of the GNU General Public License     *
#*   along with this program; if not, write to the                         *
#*   Free Software Foundation, Inc.,                                       *
#*   51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.         *
#***************************************************************************

import datetime, gettext, locale, md5, os, re, signal, subprocess, sys, tempfile, threading, time

if (int(sys.version.split()[0].split(".")[0]) > 2):
    import configparser

else:
    import ConfigParser as configparser

try:
    from PyQt4.QtCore import *
    from PyQt4.QtGui import *
    from PyQt4.QtWebKit import *

except:
    msgError = "PyQt is not istalled."
    if sys.stdout.isatty():
        print(msgError)

    else:
        parameters = ["kdialog", "--title", os.path.basename(sys.argv[0]), "--error", msgError]
        dialogProcess = subprocess.Popen(parameters, stdout=subprocess.PIPE)

    quit()

try:
    import PyKDE4.kdecore as kdecore
    from PyKDE4.kdecore import i18n, KAboutData, KCmdLineArgs, KCmdLineOptions, ki18n, KUrl
    from PyKDE4.kdeui import KApplication, KIconLoader, KMessageBox
    from PyKDE4.soprano import Soprano

except:
    msgError = "PyKDE is not istalled."
    if sys.stdout.isatty():
        print(msgError)

    else:
        parameters = ["kdialog", "--title", os.path.basename(sys.argv[0]), "--error", msgError]
        dialogProcess = subprocess.Popen(parameters, stdout=subprocess.PIPE)

    quit()

try:
    from PyKDE4.nepomuk2 import Nepomuk2

except:
    msgError = "Nepomuk2 Python Bindings are not installed."
    if sys.stdout.isatty():
        print(msgError)

    else:
        parameters = ["kdialog", "--title", os.path.basename(sys.argv[0]), "--error", msgError]
        dialogProcess = subprocess.Popen(parameters, stdout=subprocess.PIPE)

    quit()



#_BUG: carácter ' de Singin' in the Rain
#_BUG: fallan las búsquedas con el carácter ":"
#_BUG: encoding incorrecto
#_BUG: sample rate se visualiza en notación científica
#_BUG: error: [Errno 5] Input/output error la llamar al programa sin la consola
#_BUG: uri incorrecta en el link al album de la pieza musical
#_BUG: if file is unplugged and contains character "]" file is not displayed properly
#_TODO: visualizar las fechas correctamente
#_TODO: los links a visor deben funcionar con los discos desconectados
#_BUG: Modifiers "+" and "-" were not working filtering commands.
#_BUG: Duplicate entries, one for rdf:type of resourcer, when self.caseInsensitiveSort = True
#_TODO: sort case insensitive, columna lower(?x) AS ?sort
#_TODO: añadir totales y tiempos en consola
#_TODO: añadir al resource viewer los siguientes links: . << < > >>
#_TODO: extraer tipo y label de la propia db. Esto está actualmente hardcoded y
#_TODO: musicpiece debe de incluir el intérprete
#_TODO: añadir más información al contacto en la vista de resultados
#_TODO: implementar cache al moverse de atrás adelante (ojo con la vista por partes)
#_BUG: BUG001 -> negation without a shorcut is failing.
#_TODO: paréntesis

#TODO: bif:lower(?x) in ('x', 'y', 'z')
#TODO: añadir soporte a nepomuk:/ en consola
#TODO: count()
#select count(?x0) as ?cuantos
#where {
#{
#query a contar
#}
#}
#TODO: configuración externa
#TODO: multilenguage
#TODO: soporte para la gestión de tags. Idea:
#       Más usados: los 10 tags más usados listados alfabéticamente.
#       Usados: los últimos tags usados, debajo los últimos que has usado.
#       Alfabética: la vista normal.
#       Botón de eliminar todos.
#TODO: añadir soporte a --connect, --disconnect, --daemonize y moverlos a Nepoogle

#IF BUILD
#INCLUDE lglobals.py
#ELSE
from lglobals import *
#ENDIF

_ = gettext.gettext

#IF BUILD
#INCLUDE lfunctions.py
#ELSE
from lfunctions import *
#ENDIF

#IF BUILD
#INCLUDE clsparql.py
#ELSE
from clsparql import *
#ENDIF

#IF BUILD
#INCLUDE clsparql2.py
#ELSE
from clsparql2 import *
#ENDIF

#IF BUILD
#INCLUDE cldataformat.py
#ELSE
from cldataformat import *
#ENDIF


#
# cCompleter class
#
class cCompleter(QCompleter):

    separator = " "

    def __init__(self, sparqlBuilderV1, *args):
        super(cCompleter, self).__init__(*args)

        model = QStringListModel()
        wordList = [ \
                    u"and", u"or",\
                    ]

        if sparqlBuilderV1:
            oSparqlBuilder = cSparqlBuilder()

        else:
            oSparqlBuilder = cSparqlBuilder2()

        for shortcut in oSparqlBuilder.shortcuts:
            wordList += [shortcut[1] + ":"]

        for command in oSparqlBuilder.commands:
            if (command[0] in ("--help", "--musicplayer", "--playlist", "--playmixed", "--shownepoogleupdates")):
                wordList += [command[0]]

            else:
                wordList += [command[0] + ":"]

        model.setStringList(wordList)

        self.setMaxVisibleItems(25)
        self.setModel(model)
        self.setCaseSensitivity(Qt.CaseInsensitive);
        self.setModelSorting(QCompleter.CaseSensitivelySortedModel)

        #self.setCompletionMode(QCompleter.PopupCompletion)
        #self.setCompletionMode(QCompleter.InlineCompletion)


    def pathFromIndex(self, index):
        path = QCompleter.pathFromIndex(self, index)

        lst = str(self.widget().text()).split(self.separator)
        if len(lst) > 1:
            path = '%s%s%s' % (self.separator.join(lst[:-1]), self.separator, path)

        return path


    def splitPath(self, path):
        path = str(path.split(self.separator)[-1]).lstrip(self.separator)
        return [path]


#
# cWebView class
#
class cWebView(QWebView):

    owner = None

    def __init__(self, *args):
        super(cWebView, self).__init__(*args)

        #self.setContextMenuPolicy(Qt.PreventContextMenu)
        #self.setContextMenuPolicy(Qt.CustomContextMenu)
        self.owner = args[0]
        self.page().setLinkDelegationPolicy(QWebPage.DelegateAllLinks)
        self.page().setForwardUnsupportedContent(True)


    #def acceptNavigationRequest(frame, request, navigationType):
        #print("acceptNavigationRequest", frame, request, navigationType)


    #def createWindow(self, type):
        #print("createWindow", type)


    #def customContextMenuRequested(self, pos):
    #    print('customContextMenuRequested')


    #def contextMenuEvent(self, event):
    #    if False:
    #        self.popMenu = QMenu(self)
    #        self.popMenu.addAction("Open in New Window", self, SLOT(self.openLinkInNewWindow))
    #        self.popMenu.addSeparator()

    #    else:
    #        super(cWebView, self).contextMenuEvent(event)


    #def dragEnterEvent(self, event):
    #    print "dragEnterEvent", event.dropAction(), event.proposedAction(), event.spontaneous()
    #    event.setAccepted(True)

        #if (event.mimeData().hasFormat("text/plain")):
            #event.setDropAction(Qt.CopyAction)
            #event.accept()
            #print "Accepted: %s" % event.isAccepted()
            #event.acceptProposedAction();
            #print "Accepted: %s" % event.isAccepted()

        #self.dragOver = True;
        #self.update();


    def dragMoveEvent(self, event):
        if (event.mimeData().hasFormat("text/plain")):
            event.setAccepted(True)


    def dropEvent(self, event):
        self.owner.dropHandler(event)


    def mousePressEnter(self, event):
        event.setAccepted(True)


    def mouseReleaseEnter(self, event):
        event.setAccepted(True)


    #def openLinkInNewWindow(self, url):
    #    print(url)


    #def triggerPageAction(action, checked):
    #    print(checked, action)


#
# NepoogleMain class
#
class NepoogleMain(QMainWindow):

    def __init__(self):
        self.windows = []
        self.windowsCount = 0


    def newWindow(self, searchString = '', verboseMode = False, screenRect = None, SPARQLBuilderV1 = False):
        try:
            self.windows += [Nepoogle(self, searchString, verboseMode, QDesktopWidget().availableGeometry(-1), SPARQLBuilderV1)]
            self.windowsCount += 1
            print self.windowsCount
            self.windows[-1].show()
            self.windows[-1].repaint()
            if searchString:
                self.windows[-1].execQuery()

        except:
            if not self.windowsCount:
                sys.exit()


    def closeWindow(self, objNepoogle = None):
        try:
            self.windows.remove(objNepoogle)

        except:
            pass

        self.windowsCount -= 1
        print self.windowsCount
        if (self.windowsCount <= 0):
            sys.exit()


#
# Nepoogle class
#
class Nepoogle(QWidget):
    autoResize = True
    cache = []
    cacheRendered = []
    cfgId = "General"
    cfgIdMacros = "Macros"
    currUri = None
    clearResourceManagerCache = True
    defaultTextInSearchControl = _(u'Type search here')
    keyModifiers = Qt.NoModifier
    lastOntologySelected = ONTOLOGY_TITLE
    lastSPARQLQuery = ""
    macros = []
    model = None
    navigationData = []
    nepoogleMain = None
    pendingQuery = False
    queriesIndex = -1
    queryMethod = None
    renderedCache = ''
    renderedRows = 0
    renderSize = 50
    resizeMainWindowInMusicPlayerView = True
    resultData = []
    resultStructure = []
    resultTime = None
    screenHeight = 600
    screenWidth = 800
    sparql = None
    sparqlBuilderV1 = False
    textToFind = ""
    threadModeEnabled = False
    verboseMode = False
    warningsList = []

    iconProcessIdle = KIconLoader().iconPath('process-idle', KIconLoader.NoGroup)

    def __init__(self, parent = None, searchString = '', verboseMode = False, screenRect = None, SPARQLBuilderV1 = False):
        super(Nepoogle, self).__init__(None)

        #self.nepoogleMain = parent
        global cfgManager
        if cfgManager.cfg[self.cfgId]:
            for key in cfgManager.cfg[self.cfgId]:
                value = cfgManager.cfg[self.cfgId][key][0]
                self.__dict__[key] = value
                #print("%s: value = %s, readed = %s" % (key, self.__dict__[key], value))

        if cfgManager.cfg[self.cfgIdMacros]:
            self.macros = cfgManager.cfg[self.cfgIdMacros]

        if (screenRect != None):
            self.screenHeight = screenRect.height()
            self.screenWidth = screenRect.width()

        self.verboseMode = verboseMode

        if DO_NOT_USE_NEPOMUK:
            self.model = Soprano.Client.DBusModel('org.kde.NepomukStorage', '/org/soprano/Server/models/main')

        else:
            self.model = Nepomuk2.ResourceManager.instance().mainModel()

        self.sparqlBuilderV1 = SPARQLBuilderV1

        #self.setGeometry(300, 300, 250, 150)
        #self.setWindowTitle(os.path.basename(sys.argv[0]))
        self.setWindowTitle(PROGRAM_NAME)
        #self.setWindowIcon(QIcon('icon.png'))
        self.setWindowIcon(QIcon(KIconLoader().loadIcon('nepomuk', KIconLoader.NoGroup, KIconLoader.SizeSmall)))

        self.leSearch = QLineEdit(self)
        self.leSearch.setCompleter(cCompleter(self.sparqlBuilderV1))
        self.leSearch.selectOnEntry = True

        self.pbBackward = QPushButton(self)
        self.pbBackward.setIcon(QIcon(KIconLoader().loadIcon('go-previous', KIconLoader.NoGroup, KIconLoader.SizeSmall)))
        #self.pbBackward.setGeometry(QRect(self.leSearch.height(), self.leSearch.height(), self.leSearch.height(), self.leSearch.height()))
        self.pbBackward.setToolTip(_("Go backward"))
        self.connect(self.pbBackward, SIGNAL("clicked()"), self.goBackward)

        self.pbForward = QPushButton(self)
        self.pbForward.setIcon(QIcon(KIconLoader().loadIcon('go-next', KIconLoader.NoGroup, KIconLoader.SizeSmall)))
        self.pbForward.setToolTip(_("Go fordward"))
        #self.pbForward.setGeometry(QRect(self.leSearch.height(), self.leSearch.height(), self.leSearch.height(), self.leSearch.height()))
        self.connect(self.pbForward, SIGNAL("clicked()"), self.goForward)

        self.pbRefreshStop = QPushButton(self)
        self.pbRefreshStop.setIcon(QIcon(KIconLoader().loadIcon('view-refresh', KIconLoader.NoGroup, KIconLoader.SizeSmall)))
        self.pbRefreshStop.setToolTip(_("Refresh"))
        self.connect(self.pbRefreshStop, SIGNAL("clicked()"), self.refreshStopAction)

        self.pbSparql = QPushButton(self)
        self.pbSparql.setIcon(QIcon(KIconLoader().loadIcon('sparql', KIconLoader.NoGroup, KIconLoader.SizeSmall)))
        self.pbSparql.setToolTip(_("Edit Sparql"))
        #self.pbForward.setGeometry(QRect(self.leSearch.height(), self.leSearch.height(), self.leSearch.height(), self.leSearch.height()))
        self.connect(self.pbSparql, SIGNAL("clicked()"), self.editSparql)

        self.pbHelp = QPushButton(self)
        self.pbHelp.setIcon(QIcon(KIconLoader().loadIcon('help-contents', KIconLoader.NoGroup, KIconLoader.SizeSmall)))
        self.pbHelp.setToolTip(_("Help"))
        #self.pbForward.setGeometry(QRect(self.leSearch.height(), self.leSearch.height(), self.leSearch.height(), self.leSearch.height()))
        self.connect(self.pbHelp, SIGNAL("clicked()"), self.showHelp)

        self.hbl = QHBoxLayout()
        self.hbl.setSpacing(1)
        self.hbl.addWidget(self.pbBackward)
        self.hbl.addWidget(self.pbForward)
        self.hbl.addWidget(self.pbRefreshStop)
        self.hbl.addWidget(self.leSearch)
        self.hbl.addWidget(self.pbSparql)
        self.hbl.addWidget(self.pbHelp)

        self.wvOutput = cWebView(self)
        self.connect(self.wvOutput, SIGNAL("linkClicked(const QUrl&)"), self.linkClicked)
        self.connect(self.wvOutput, SIGNAL("loadStarted()"), self.loadStarted)
        self.connect(self.wvOutput, SIGNAL("loadFinished(bool)"), self.loadFinished)
        self.connect(self.wvOutput, SIGNAL("loadProgress(int)"), self.loadProgress)
        #self.connect(self.wvOutput, SIGNAL("dropEvent(QDropEvent*)"), self.dropHandler)
        #self.connect(self.wvOutput.page(), SIGNAL("customContextMenuRequested(const QPoint&)"), self.customContextMenuRequested)

        # This action has no changes.
        self.actionOpenLink = self.wvOutput.pageAction(QWebPage.OpenLink)
        self.connect(self.actionOpenLink, SIGNAL("triggered(bool)"), self.openLink)

        # DownloadLinkToDisk renamed and used as OpenLinkInNewWindow
        self.actionDownloadLinkToDisk = self.wvOutput.pageAction(QWebPage.DownloadLinkToDisk)
        self.actionDownloadLinkToDisk.setText(_("Open in New Window"))
        #self.connect(self.actionDownloadLinkToDisk, SIGNAL("triggered(bool)"), self.downloadLinkToDisk)

        # Invisible OpenLinkInNewWindow.
        self.actionOpenLinkInNewWindow = self.wvOutput.pageAction(QWebPage.OpenLinkInNewWindow)
        self.actionOpenLinkInNewWindow.setVisible(False)
        #self.connect(self.actionOpenLinkInNewWindow, SIGNAL("triggered(bool)"), self.openLinkInNewWindow)

        # Invisible OpenImageInNewWindow.
        self.actionOpenImageInNewWindow = self.wvOutput.pageAction(QWebPage.OpenImageInNewWindow)
        self.actionOpenImageInNewWindow.setVisible(False)

        self.connect(self.wvOutput.page(), SIGNAL("downloadRequested(const QNetworkRequest&)"), self.downloadRequested)
        self.connect(self.wvOutput.page(), SIGNAL("unsupportedContent(QNetworkReply*)"), self.unsupportedContent)
        self.wvOutput.page().setForwardUnsupportedContent(True)

        self.grid = QGridLayout()
        self.grid.setSpacing(10)
        #self.grid.addWidget(self.leSearch, 1, 1)
        self.grid.addLayout(self.hbl, 1, 1)
        self.grid.addWidget(self.wvOutput, 2, 1, 5, 1)


        self.setLayout(self.grid)

        if self.autoResize:
            self.resize(int((self.screenWidth) / 2), self.screenHeight - 50)

        if searchString == '':
            self.leSearch.setText(self.defaultTextInSearchControl)

        else:
            self.leSearch.setText(searchString)

        self.leSearch.setSelection(0,999)
        self.leSearch.setFocus()

        if searchString == '':
            self.execQuery('--help')


    def setAppCursor(self, cursor = None):
        if (cursor == None):
            cursor = Qt.ArrowCursor

        KApplication.setOverrideCursor(QCursor(cursor))


    def setPendingQuery(self, enableIt = True):
        self.pendingQuery = enableIt
        if self.threadModeEnabled:
            if enableIt:
                self.pbRefreshStop.setIcon(QIcon(KIconLoader().loadIcon('dialog-cancel', KIconLoader.NoGroup, KIconLoader.SizeSmall)))
                self.pbRefreshStop.setToolTip(_("Cancel query"))

            else:
                self.pbRefreshStop.setIcon(QIcon(KIconLoader().loadIcon('view-refresh', KIconLoader.NoGroup, KIconLoader.SizeSmall)))
                self.pbRefreshStop.setToolTip(_("Refresh"))


    def closeEvent(self, event):
        #self.nepoogleMain.closeWindow(self)
        sys.exit()


    #def downloadLinkToDisk(self, checked):
    #    print("downloadLinkToDisk", checked)
    #    pass


    def downloadRequested(self, request):
        #print("downloadRequested", request.url().toString())
        url = toUnicode(request.url().toString())
        if url != "":
            if url[:9] == 'nepomuk:/':
                pass

            elif url[:7] == 'query:/':
                url = url[7:]

            elif url[:6] == "file:/":
                subprocess.Popen(["kioclient", "exec", url])
                url = ''

            else:
                url = ''

            if url != '':
                print(toUtf8(url))
                subprocess.Popen([PROGRAM_URL, "--gui", toUtf8(url)])


    def unsupportedContent(self, request):
        #print("downloadRequested", request.url().toString())
        QMessageBox.warning(self, '%s - %s' % (PROGRAM_NAME, _("warning")), "Option not available yet.")


    def openLink(self, checked):
        #print("openLink", checked, toUtf8(self.wvOutput.page().currentFrame().requestedUrl()))
        self.linkClicked(self.wvOutput.page().currentFrame().requestedUrl(), True)


    def openLinkInNewWindow(self, checked):
        #print("openLinkInNewWindow", checked, toUtf8(self.wvOutput.page().currentFrame().requestedUrl()))
        url = toUnicode(self.wvOutput.page().currentFrame().requestedUrl().toString())
        if url:
            print(toUtf8(url))
            if (url[:9] == 'nepomuk:/'):
                pass

            elif (url[:7] == 'query:/'):
                url = url[7:]

            elif (url[:6] == "file:/"):
                subprocess.Popen(["kioclient", "exec", url])
                return False

            else:
                return False

            if url:
                #subprocess.Popen([PROGRAM_URL, "--gui", toUtf8(url)])
                nepoogleMain.addWindow(url, False, QDesktopWidget().availableGeometry(-1), self.sparqlBuilderV1)
                nepoogle = Nepoogle(None, searchString, verboseMode, QDesktopWidget().availableGeometry(-1), SPARQLBuilderV1)
                nepoogle.show()
                nepoogle.repaint()
                if searchString != '':
                    nepoogle.execQuery()


    def loadFinished(self, ok):
        #print('loadFinished:', ok)
        self.repaint()
        if self.pendingQuery:
            self.execQuery()

        self.textToFind = ""

    def loadProgress(self, progress):
        #print('loadProgress:', progress)
        pass


    def loadStarted(self):
        #print('loadStarted', self.wvOutput.url().toString())
        pass


    def keyPressEvent(self, event):
        if event.key() == Qt.Key_Return or event.key() == Qt.Key_Enter:
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.queryMethod = "manual"
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)

        elif event.key() == Qt.Key_F5:
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.queryMethod = "refresh"
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)

        elif event.key() == Qt.Key_F3:
            self.findText(True)

        elif event.modifiers() == Qt.ControlModifier:
            if event.key() == Qt.Key_PageUp:
                self.linkClicked(QUrl("navigate:/first/navbutton"))

            elif event.key() == Qt.Key_PageDown:
                self.linkClicked(QUrl("navigate:/last/navbutton"))

            elif event.key() == Qt.Key_Left:
                self.linkClicked(QUrl("navigate:/previous/navbutton"))

            elif event.key() == Qt.Key_Right:
                self.linkClicked(QUrl("navigate:/next/navbutton"))

            elif event.key() == Qt.Key_Delete:
                uri = toUnicode(self.leSearch.text()).strip()
                if uri[:13] == 'nepomuk:/res/':
                    self.linkClicked(QUrl("remove:/" + uri))

            elif event.key() == Qt.Key_F:
                self.findText()

            elif event.key() == Qt.Key_Plus:
                self.addProperty()

            #else
                #pass

        elif event.key() == Qt.Key_Escape:
            self.close()

        #elif event.key() == QKeySequence("Ctrl+E"):
        #    self.leSearch.keyPressEvent(self, event)

        #else
            #pass

        self.keyModifiers = event.modifiers()


    def keyReleaseEvent(self, event):
        self.keyModifiers = event.modifiers()


    def findText(self, again = False):
        if (not again or (self.textToFind == "")):
            self.textToFind = dialogInputBox(_("Text to find:"))

        self.wvOutput.findText("", QWebPage.HighlightAllOccurrences)
        if self.wvOutput.findText(self.textToFind, QWebPage.FindWrapsAroundDocument):
            self.wvOutput.findText(self.textToFind, QWebPage.HighlightAllOccurrences)

        else:
            QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("warning")), _("Text not found."))


    def linkClicked(self, url, forceExec = False):
        url = toUnicode(url.toString())
        print(toUtf8(url))

        if (url[:13] == "addresource:/"):
            mustRefresh = SLEEP_NO_SLEEP
            ontology = url[13:].split("&")
            try:
                uri = ontology[1]

            except:
                uri = ""

            ontology = ontology[0]
            if ontology == ONTOLOGY_TYPE_CONTACT:
                if (uri != ""):
                    if INTERNAL_RESOURCE:
                        resource = cResource(uri)

                    else:
                        resource = Nepomuk2.Resource(uri)

                fullname = _("New contact")
                newResource = Nepomuk2.Resource(QString(fullname), NOC(ontology, True))
                newResource.addProperty(NOC(ONTOLOGY_FULLNAME, True), toVariant(fullname))
                newResource.removeProperty(NOC(ONTOLOGY_IDENTIFIER, True))
                newResource.removeProperty(NOC("nao:prefLabel", True))

                mustRefresh = SLEEP_AFTER_UPDATE

            if mustRefresh > SLEEP_NO_SLEEP:
                time.sleep(mustRefresh)
                self.linkClicked(QUrl(newResource.uri()), True)

        elif url[:11] == "autocover:/":
            uri = url[11:]
            oDataFormat = cDataFormat("", self.model, self.screenWidth, None, None, cfgManager)
            coverUrl = oDataFormat.getCoverUrl(uri, "", False) # unknown url and don't use html encodig for url.
            if coverUrl in ("", "file://" + oDataFormat.iconNoCover) :
                QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("Cover not detected.\n\nYou can drag&drop and image as \"artwork (nmm:artwork)\" to manually set one."))

            else:
                self.addProperty(uri, "nmm:artwork", coverUrl)
                QMessageBox.information(self, "%s - %s" % (PROGRAM_NAME, _("Information")), _("Added as album cover the next file:\n\n%s") % coverUrl)

        elif url[:9] == "command:/":
            url = url[9:]
            self.leSearch.setText(url)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.wvOutput.setHtml('<html><body><h3>Reading... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            if forceExec:
                self.execQuery()
                self.setPendingQuery(False)

        elif url[:8] == 'delete:/':
            reply = QMessageBox.question(self, '%s - delete item' % PROGRAM_NAME, "Do you really want to send to trash this item??\n\n%s" % url[8:], QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
            if reply == QMessageBox.Yes:
                subprocess.Popen(['kioclient', 'move', url[8:], 'trash:/'])
                self.setAppCursor(Qt.BusyCursor)
                self.setPendingQuery(True)
                self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                                        % self.iconProcessIdle)
                if forceExec:
                    self.execQuery()
                    self.setPendingQuery(False)

        elif url[:6] == 'dolp:/':
            subprocess.Popen(['dolphin', url[6:]])

        elif url[:14] == 'googlesearch:/':
            url = "http://www.google.com:/search?q=%s&ie=UTF-8&oe=UTF-8" % url[14:].replace("?", "%3F").replace("&", "%26")
            subprocess.Popen(["kioclient", "exec", url])

        elif (url[:16] == "html2clipboard:/"):
            try:
                #TODO: check this because seems like toHtml() is not working properly.
                html = toUnicode(self.wvOutput.page().mainFrame().toHtml().toUtf8())
                if html:
                    subprocess.Popen(["qdbus", "org.kde.klipper", "/klipper", "setClipboardContents", html])

            except:
                pass


        elif url[:6] == 'konq:/':
            subprocess.Popen(['konqueror', url[6:]])

        elif url[:10] == 'navigate:/':
            if ((self.navigationData == []) or (len(self.navigationData) < 2)):
                return True

            idx = lindex(self.navigationData, self.leSearch.text(), 0)
            if not (idx == None):
                lenIgnoredRowMark = len(self.cache[self.queriesIndex].ignoredRowMark)
                navigateTo = url[10:].lower().split("/")
                if (navigateTo[0] == "first"):
                    tryIdx = 0
                    while (self.navigationData[tryIdx][0][:lenIgnoredRowMark] == self.cache[self.queriesIndex].ignoredRowMark):
                        tryIdx += 1
                        if (tryIdx >= (len(self.navigationData) - 1)):
                            break

                elif (navigateTo[0] == "previous"):
                    if (idx > 0):
                        tryIdx = idx - 1
                        while (self.navigationData[tryIdx][0][:lenIgnoredRowMark] == self.cache[self.queriesIndex].ignoredRowMark):
                            tryIdx -= 1
                            if (tryIdx <= 0):
                                break

                elif (navigateTo[0] == "next"):
                    if (idx <= len(self.navigationData) - 1):
                        tryIdx = idx + 1

                        while (self.navigationData[tryIdx][0][:lenIgnoredRowMark] == self.cache[self.queriesIndex].ignoredRowMark):
                            tryIdx += 1
                            if (tryIdx >= (len(self.navigationData) - 1)):
                                break

                elif (navigateTo[0] == "last"):
                    tryIdx = len(self.navigationData) - 1
                    while (self.navigationData[tryIdx][0][:lenIgnoredRowMark] == self.cache[self.queriesIndex].ignoredRowMark):
                        tryIdx -= 1
                        if (tryIdx <= 0):
                            break

                #else:
                    #pass

                if ((tryIdx >= 0) and (tryIdx < len(self.navigationData))):
                    idx = tryIdx

                try:
                    self.queryMethod = navigateTo[1]

                except:
                    pass

                self.linkClicked(QUrl(self.navigationData[idx][0]), False)


        elif url[:9] == 'nepomuk:/':
            self.leSearch.setText(url)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.wvOutput.setHtml('<html><body><h3>Reading... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            if forceExec:
                self.execQuery()
                self.setPendingQuery(False)

        elif url[:6] == 'prop:/':
            subprocess.Popen(['kioclient', 'openProperties', url[6:]])

        elif url[:9] == "propadd:/":
            uri = url[9:]
            self.addProperty(uri)

        elif url[:10] == "propedit:/":
            uri = url[10:].split("&")
            if (len(uri) >= 2):
                operation = "add"
                if (self.keyModifiers == Qt.NoModifier):
                    try:
                        operation = uri[2]

                    except:
                        pass

                elif (self.keyModifiers == Qt.ShiftModifier):
                    operation = "edit"

                elif (self.keyModifiers == Qt.ControlModifier):
                    operation = "remove"

                if (operation == "add"):
                    self.addProperty(uri[0], uri[1])

                elif (operation == "remove"):
                    self.removeProperty(uri[0], uri[1])

                else:
                    self.editProperty(uri[0], uri[1])

        elif url[:7] == 'query:/':
            urlElements = url[7:].split("'")
            if len(urlElements) >= 3:
                tmpUrl = urlElements[0] + '"'
                for i in range(1, len(urlElements) - 2):
                    tmpUrl += urlElements[i] + "'"
                tmpUrl += urlElements[-2] + '"'

            elif len(urlElements) == 2:
                tmpUrl = urlElements[0] + "'" + urlElements[1] + "'"

            elif len(urlElements) == 1:
                tmpUrl = "'" + urlElements[0] + "'"

            else:
                pass

            self.leSearch.setText(tmpUrl)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            if forceExec:
                self.execQuery()
                self.setPendingQuery(False)

        elif url[:9] == "reindex:/":
            subprocess.Popen(["nepomukindexer", url[9:].replace("?", "%3F")])

        elif url[:8] == 'remove:/':
            mode = url[8:].lower()
            if (mode == "all"):
                reply = QMessageBox.question(self, '%s - remove all listed resources' % PROGRAM_NAME, "Really delete all listed resources?\n\nCaution!!! This option can't be undone!!!", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if (reply == QMessageBox.Yes):
                    uris = []
                    uri = toUnicode(self.leSearch.text()).strip()
                    if (not uri[:13] == "nepomuk:/res/"):
                        if self.cache[self.queriesIndex].navegable:
                            lenIgnoredRowMark = len(self.cache[self.queriesIndex].ignoredRowMark)
                            for uri in self.cache[self.queriesIndex].data:
                                if not (uri[0][:lenIgnoredRowMark] == self.cache[self.queriesIndex].ignoredRowMark):
                                    uris += [uri[0]]

                    else:
                        uris += [uri]

                    self.setAppCursor(Qt.BusyCursor)
                    for uri in uris:
                        resource = Nepomuk2.Resource(uri)
                        itemType = NOCR(resource.type())
                        resource.remove()

                    self.setAppCursor()

                    self.setAppCursor(Qt.BusyCursor)
                    self.setPendingQuery(True)
                    self.queryMethod = "refresh"
                    self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                                            % self.iconProcessIdle)
                    if forceExec:
                        self.execQuery()
                        self.setPendingQuery(False)

            else:
                reply = QMessageBox.question(self, '%s - remove resource' % PROGRAM_NAME, "Really delete this resource?", QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if (reply == QMessageBox.Yes):
                    resource = Nepomuk2.Resource(QUrl(url[8:]))
                    resource.remove()
                    self.setAppCursor(Qt.BusyCursor)
                    self.setPendingQuery(True)
                    self.queryMethod = "refresh"
                    self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                                            % self.iconProcessIdle)
                    if forceExec:
                        self.execQuery()
                        self.setPendingQuery(False)

        elif url[:8] == 'render:/':
            self.leSearch.readOnly = True
            self.setAppCursor(Qt.BusyCursor)
            self.wvOutput.setHtml('<html><body><h3>Rendering... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            self.wvOutput.repaint()
            self.repaint()

            html = self.cache[self.queriesIndex].formatAsHtml(url[8:])
            if (self.queriesIndex >= 0):
                if ((self.cache[self.queriesIndex-1].navegable) or (self.cache[self.queriesIndex].navegable)):
                    dataIndex = lindex(self.navigationData, self.leSearch.text())
                    if (dataIndex != None):
                        dataLength = len(self.navigationData)
                        html = html.replace("<navigator />", self.cache[self.queriesIndex].htmlRenderLink("navigator", dataIndex, dataLength))

            self.wvOutput.setHtml(html)

            self.setAppCursor()
            self.leSearch.readOnly = False
            self.repaint()

        elif url[:5] == 'run:/':
            if url[:12] == 'run:/file://':
                subprocess.Popen(["kioclient", "exec", url[12:]])

            else:
                subprocess.Popen(["kioclient", "exec", url[5:]])

        #elif url[:6] == 'view:/':
            #self.leSearch.setText(url[6:])
            #self.setAppCursor(Qt.BusyCursor)
            #self.setPendingQuery(True)
            #self.wvOutput.setHtml('<html><body><h3>Reading... <img src="file://%s"></h3></body></html>' \
                                    #% self.iconProcessIdle)

        elif url[:11] == "setrating:/":
            rating = url[11:]
            try:
                rating = int(rating)

            except:
                rating = 0

            self.setRating(None, rating)

        elif (url[:18] == "sparql2clipboard:/"):
            try:
                if (self.lastSPARQLQuery != ""):
                    subprocess.Popen(["qdbus", "org.kde.klipper", "/klipper", "setClipboardContents", self.lastSPARQLQuery])

            except:
                pass

        else:
            # In KDE we trust.nepomuk:/res/eee8837d-27ab-43ac-a34a-43d339102c1c
            subprocess.Popen(["kioclient", "exec", url])


        # Clear always modifiers because the next keypress could happen in other window.
        self.keyModifiers = Qt.NoModifier


    def setRating(self, uri = None, rating = None):
        if (uri == None):
            uri = toUnicode(self.leSearch.text()).strip()
            if not uri[:13] == "nepomuk:/res/":
                QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("You can only add properties in the Resource Viewer."))
                return False

        # Getting the resource.
        if (vartype(uri) == "Resource"):
            resource = uri

        else:
            if (self.model == None):
                return False

            if INTERNAL_RESOURCE:
                resource = cResource(uri)

            else:
                resource = Nepomuk2.Resource(uri)

        # Numeric rating conversion.
        if (vartype(rating) == "int"):
            pass

        elif (vartype(rating) in ("str", "unicode")):
            try:
                rating = int(rating)

            except:
                rating = 0

        elif (vartype(rating) == "QString"):
            try:
                rating = int(toUnicode(rating))

            except:
                rating = 0

        # Setting the new rating.
        if ((rating == None) or (rating < 0)):
            resource.removeProperty(toVariant(QUrl(resource.ratingUri())))
            rating = None

        else:
            rating = max(min(rating, 10), 0)
            resource.setRating(rating)

        if (vartype(uri) != "Resource"):
            time.sleep(SLEEP_AFTER_UPDATE)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.queryMethod = "refresh"
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)

        return rating


    def addProperty(self, uri = None, ontology = "", value = ""):
        if (uri == None):
            uri = toUnicode(self.leSearch.text()).strip()

        if (not uri[:13] == "nepomuk:/res/"):
            QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("You can only add properties in the Resource Viewer."))
            return False

        mustRefresh = SLEEP_NO_SLEEP

        if (self.model == None):
            return False

        if INTERNAL_RESOURCE:
            resource = cResource(uri)

        else:
            resource = Nepomuk2.Resource(uri)

        resourceMainType = NOCR(resource.type())
        if not ontology:
            query = 'SELECT DISTINCT ?r\n' \
                    'WHERE {\n' \
                        '\t{\n' \
                        '\t\t?r rdfs:domain %s . FILTER(REGEX(?r, "/nco#", "i") || REGEX(?r, "/nmm#", "i")) .\n' \
                        '\t} UNION {\n' \
                        '\t\t?r rdfs:range ?range . FILTER(?range IN (rdfs:Literal, xsd:date, xsd:dateTime, xsd:string)) . FILTER(REGEX(?r, "/nco#", "i") || REGEX(?r, "/nmm#", "i")) .\n' \
                        '\t}\n' \
                    '}\n' \
                    % (resourceMainType)

            values = []
            values += [[ONTOLOGY_ALTLABEL, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_ALTLABEL)["label"], ONTOLOGY_ALTLABEL)], \
                        [ONTOLOGY_COMMENT, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_COMMENT)["label"], ONTOLOGY_COMMENT)], \
                        [ONTOLOGY_DESCRIPTION, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_DESCRIPTION)["label"], ONTOLOGY_DESCRIPTION)], \
                        [ONTOLOGY_LANGUAGE, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_LANGUAGE)["label"], ONTOLOGY_LANGUAGE)], \
                        [ONTOLOGY_NUMERIC_RATING, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_NUMERIC_RATING)["label"], ONTOLOGY_NUMERIC_RATING)], \
                        [ONTOLOGY_PREFLABEL, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_PREFLABEL)["label"], ONTOLOGY_PREFLABEL)], \
                        [ONTOLOGY_SUBJECT, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_SUBJECT)["label"], ONTOLOGY_SUBJECT)], \
                        [ONTOLOGY_TITLE, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_TITLE)["label"], ONTOLOGY_TITLE)], \
                        ]
            queryResultSet = self.model.executeQuery(query, SOPRANO_QUERY_LANGUAGE)
            if queryResultSet.isValid():
                while queryResultSet.next():
                    ontology = NOCR(toUnicode(queryResultSet["r"].toString()))
                    values += [[ontology, "%s (%s)" % (self.ontologyInfo(ontology)["label"], ontology)]]

            if (values != []):
                parameters = []
                values = sorted(values, key=lambda item: item[1].lower())
                for item in values:
                    if (item[0] == self.lastOntologySelected):
                        status = "on"

                    else:
                        status = "off"

                    parameters += [item[0], item[1], status]

                ontologyResource, labelResource = dialogList(parameters, _("Select an ontology:"))
                if not ontologyResource:
                    return False

        else:
            ontologyResource = ontology
            labelResource = ontology

        ontologyInfo = None
        if ontologyResource:
            ontologyInfo = self.ontologyInfo(ontologyResource)
            if (ontologyInfo["cardinality"] == 1):
                # Check if exists.
                if resource.hasProperty(NOC(ontologyResource)):
                    QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("There can be only one ontology of this kind per resource but you can edit it's value using Shift+Click or even delete it."))
                    return False

        if ontologyResource:
            if not value:
                value = dialogInputBox(("Value to store in \"%s\":") % ontologyInfo["label"], ontologyInfo["type"])

            if value:
                # TODO: some processing strings must be required for certain types.
                if (ontologyInfo["type"] in ("date", "datep", "datetime", "datetimep")):
                    valTemp = re.sub('[-/]', '', value.strip())
                    if valTemp.isalnum():
                        if (len(valTemp) == 6):
                            if (int(valTemp[:2]) >= 30):
                                value = "19%s-%s-%s" % (valTemp[:2], valTemp[2:4], valTemp[4:6])

                            else:
                                value = "20%s-%s-%s" % (valTemp[:2], valTemp[2:4], valTemp[4:6])

                        elif (len(valTemp) == 8):
                            value = "%s-%s-%s" % (valTemp[:4], valTemp[4:6], valTemp[6:8])

                #redirector = stderrReader()
                print("%s: property %s added" % (uri, ontologyResource))
                if ontologyResource == ONTOLOGY_NUMERIC_RATING:
                    self.setRating(resource, value)

                else:
                    resource.addProperty(NOC(ontologyResource, True), toVariant(value))

                #stderr_data = redirector.read()
                #QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _(stderr_data))

                mustRefresh = SLEEP_AFTER_UPDATE

                self.lastOntologySelected = ontologyResource

        else:
            QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("Sorry, I don't know what to do with this resource and custom ontologies are not supported yet."))

        if (mustRefresh > SLEEP_NO_SLEEP):
            time.sleep(mustRefresh)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.queryMethod = "refresh"
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)

        return True


    def editProperty(self, uri = None, ontology = None):
        if not uri:
            uri = toUnicode(self.leSearch.text()).strip()

        if (not uri[:13] == "nepomuk:/res/"):
            QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("You can only add properties in the Resource Viewer."))
            return False

        mustRefresh = SLEEP_NO_SLEEP

        if not self.model:
            return False

        if INTERNAL_RESOURCE:
            resource = cResource(uri)

        else:
            resource = Nepomuk2.Resource(uri)

        try:
            text = resource.property(NOC(ontology, True))
            if text.isStringList():
                parameters = []
                status = "on"
                # Trying to avoid the two titles bug with this oldItem.
                oldItem = ""
                for item in text.toStringList():
                    item = toUnicode(item)
                    if (item == oldItem):
                        continue

                    oldItem = item
                    parameters += [item] + [item] + [status]
                    if status == "on":
                        status = "off"

                text, dummyValue = dialogList(parameters, _("Select value to edit:"))
                if not text.strip():
                    return False

            else:
                text = toUnicode(resource.property(NOC(ontology, True)).toString())

            if (text[:13] == "nepomuk:/res/"):
                QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("You can't edit resources here, click in the resource and edit directly."))
                return False

        except:
            text = None

        if (text != None): # Handle empty values in ontologies.
            ontologyInfo = self.ontologyInfo(ontology)
            newText = dialogTextInputBox("Editing \"%s\":" % ontologyInfo["label"], text, ontologyInfo["type"])
            if (newText != text):
                #resourceReply = QMessageBox.question(self, '%s - edit value' % PROGRAM_NAME, _("Save changes to '%s'?") % (ontologyInfo["label"]), QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                #if (resourceReply == QMessageBox.Yes):
                if True:
                    print("%s: property %s edited" % (uri, ontology))
                    if (ontology == ONTOLOGY_NUMERIC_RATING):
                        self.setRating(resource, newText)

                    elif (ontologyInfo["cardinality"] == 1):
                        resource.setProperty(NOC(ontology, True), toVariant(newText))

                    else:
                        ontologyFull = NOC(ontology, True)
                        if (ontology in ("nie:url")):
                            # Caution!, strip() is mandatory here because only one line is supported.
                            newText = QUrl(newText.strip())
                            if (newText.isValid()):
                                resource.setProperty(ontologyFull, toVariant(newText))

                            else:
                                QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("Invalid url."))
                                return False

                        else:
                            resource.removeProperty(ontologyFull, toVariant(text))
                            resource.addProperty(ontologyFull, toVariant(newText))

                    mustRefresh = SLEEP_AFTER_UPDATE

        if (mustRefresh > SLEEP_NO_SLEEP):
            time.sleep(mustRefresh)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.queryMethod = "refresh"
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)

        return True


    def removeProperty(self, uri = None, ontology = None):
        if ((uri == None) or (ontology == None)):
            return False

        mustRefresh = SLEEP_NO_SLEEP

        query = 'SELECT DISTINCT ?v\n' \
                'WHERE {\n' \
                    '\t<%s> %s ?v .\n' \
                '}\n' \
                % (uri, ontology)

        values  = []
        queryResultSet = self.model.executeQuery(query, SOPRANO_QUERY_LANGUAGE)
        if queryResultSet.isValid():
            while queryResultSet.next():
                values += [NOCR(toUnicode(queryResultSet["v"].toString()))]

        if (values != []):
            resourcesList = []
            for value in values:
                if (value[:13] == "nepomuk:/res/"):
                    if INTERNAL_RESOURCE:
                        label = cResource(value).genericLabel()

                    else:
                        label = toUnicode(Nepomuk2.Resource(value).genericLabel())

                else:
                    label = value

                if not value:
                    value = "<empty>"
                    label = "<empty>"

                resourcesList += [[value, label]]

            if (len(values) > 1):
                resourcesList = sorted(resourcesList, key=lambda item: item[1])
                # Convert to 1 dimension.
                parameters = []
                status = "on"
                for param in resourcesList:
                    parameters += [param[0]] + [param[1]] + [status]
                    if status == "on":
                        status = "off"

                value, label = dialogList(parameters, _("Select the value to be removed:"))

            else:
                value = resourcesList[0][0]
                label = resourcesList[0][1]
                if not value:
                    value = "<empty>"
                    label = "<empty>"

            if ((value != None) and (value != "")):
                reply = QMessageBox.question(self, '%s - remove property' % PROGRAM_NAME, "Remove property \"%s\" with value \"%s\"?" % (self.ontologyInfo(ontology)["label"], label), QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                if (reply == QMessageBox.Yes):
                    print("%s: property %s removed" % (uri, ontology))
                    #print("Removing property: %s, %s, %s" % (uri, ontology, toUtf8(value)))
                    if (len(values) == 1):
                        resource = Nepomuk2.Resource(uri)
                        resource.removeProperty(NOC(ontology, True))
                        mustRefresh = SLEEP_AFTER_UPDATE

                    else:
                        resource = Nepomuk2.Resource(uri)
                        if (value == "<empty>"):
                            value = ""

                        resource.removeProperty(NOC(ontology, True), toVariant(value))
                        mustRefresh = SLEEP_AFTER_UPDATE

        if (mustRefresh > SLEEP_NO_SLEEP):
            time.sleep(mustRefresh)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.queryMethod = "refresh"
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)


    def dropHandler(self, event):
        supportedImageFormats = QImageReader.supportedImageFormats() + ["nef"]
        mustRefresh = SLEEP_NO_SLEEP

        #Qt::KeyboardModifiers QDropEvent::keyboardModifiers () const
        #Qt::MouseButtons QDropEvent::mouseButtons () const
        #QWidget * QDropEvent::source () const para controlar el d&d sobre si mismo.

        # Query para obtener las propiedades "oficiales".
        # SELECT * WHERE { ?r rdfs:domain %s .}

        # Query para obtener qué puede ser un resource.
        #SELECT * WHERE { ?r rdfs:range %s . }

        #TODO: rethink all this method because there are convinations that works and others not
        # and user will need feedback.
        dbOperation = "add"
        if (event.keyboardModifiers() == Qt.ControlModifier):
            dbOperation = "remove"

        uris = []
        uri = toUnicode(self.leSearch.text()).strip()
        if (not uri[:13] == "nepomuk:/res/"):
            if self.cache[self.queriesIndex].navegable:
                lenIgnoredRowMark = len(self.cache[self.queriesIndex].ignoredRowMark)
                for uri in self.cache[self.queriesIndex].data:
                    if not (uri[0][:lenIgnoredRowMark] == self.cache[self.queriesIndex].ignoredRowMark):
                        uris += [uri[0]]

            else:
                QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("You can't drop data here."))
                return False

        else:
            uris += [uri]

        if event.mimeData().hasUrls():
            imageReply = resourceReply = None
            for i in range(0, len(event.mimeData().urls())):
                url = toUnicode(event.mimeData().urls()[i].toString()).strip()
                print("url: %s" % toUtf8(url))

                dropType = None
                if (dropType == None):
                    ext = os.path.splitext(url)[1][1:].lower()
                    if (ext in supportedImageFormats):
                        if ((url[:7] == "http://") or (url[:8] == "https://")):
                            dropType = "url_image"

                        elif fileExists(url):
                            dropType = "image"

                if (dropType == None):
                    if (url[:13] == "nepomuk:/res/"):
                        dropType = "resource"

                if (dropType == None):
                    if ((url[:7] == "http://") or (url[:8] == "https://")):
                        dropType = "url"

                if (dropType == None):
                    if (url[:10] == "propedit:/"):
                        try:
                            ontValue = url[10:].split("&")[1]

                        except:
                            ontValue = ""

                        #TODO: handle better this.
                        if (len(uris) == 1):
                            self.setAppCursor(Qt.BusyCursor)
                            for uri in uris:
                                #TODO: test this.
                                self.editProperty(uri, ontValue)

                            self.setAppCursor()

                        continue

                if (dropType == None):
                    if (url[:9] == "propadd:/"):
                        self.setAppCursor(Qt.BusyCursor)
                        for uri in uris:
                            if (dbOperation == "add"):
                                self.addProperty(uri)

                            elif (dbOperation == "remove"):
                                pass

                        self.setAppCursor()
                        continue

                if (dropType == "image"):
                    if (i == 0):
                        parameters = [ONTOLOGY_MUSIC_ALBUM_COVER, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_MUSIC_ALBUM_COVER)["label"], ONTOLOGY_MUSIC_ALBUM_COVER), "off", \
                                        ONTOLOGY_DEPICTION, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_DEPICTION)["label"], ONTOLOGY_DEPICTION), "on", \
                                        ONTOLOGY_SYMBOL, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_SYMBOL)["label"], ONTOLOGY_SYMBOL), "off", \
                                        ONTOLOGY_SYMBOL_CONTACT, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_SYMBOL_CONTACT)["label"], ONTOLOGY_SYMBOL_CONTACT), "off"]

                        ontologyImages, labelImages = dialogList(parameters, _("Select an ontology:"))
                        if not ontologyImages:
                            continue

                        if (len(event.mimeData().urls()) > 1):
                            msgImagePronoun = "all images"

                        else:
                            msgImagePronoun = "next image"

                        #msgImageUrl = "\n\n" + "\n".join([toUnicode(urlItem.toString()) for urlItem in event.mimeData().urls()])
                        #imageReply = QMessageBox.question(self, _("%s - add data") % PROGRAM_NAME, _("add %s as %s?%s") % (msgImagePronoun, ontologyImages, msgImageUrl), QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                        imageReply = QMessageBox.Yes

                    if (imageReply == QMessageBox.Yes):
                        self.setAppCursor(Qt.BusyCursor)
                        for uri in uris:
                            uriResource = Nepomuk2.Resource(uri)
                            if (dbOperation == "add"):
                                uriResource.addProperty(NOC(ontologyImages, True), toVariant(url))

                            elif (dbOperation == "remove"):
                                pass

                        self.setAppCursor()
                        mustRefresh = SLEEP_AFTER_UPDATE

                elif (dropType in ("url", "url_image")):
                    #TODO: handle better this.
                    if (len(uris) == 1):
                        uri = uris[0]
                        if (dropType == "url_image"):
                            parameters = [ONTOLOGY_LINK, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_LINK)["label"], ONTOLOGY_LINK), "on", \
                                            ONTOLOGY_MUSIC_ALBUM_COVER, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_MUSIC_ALBUM_COVER)["label"], ONTOLOGY_MUSIC_ALBUM_COVER), "off", \
                                            ONTOLOGY_DEPICTION, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_DEPICTION)["label"], ONTOLOGY_DEPICTION), "on", \
                                            ONTOLOGY_SYMBOL, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_SYMBOL)["label"], ONTOLOGY_SYMBOL), "off", \
                                            ONTOLOGY_SYMBOL_CONTACT, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_SYMBOL_CONTACT)["label"], ONTOLOGY_SYMBOL_CONTACT), "off"]
                            ontologyUrl, labelUrl = dialogList(parameters, _("Select an ontology:"))
                            if not ontologyUrl:
                                continue

                            #if (len(event.mimeData().urls()) > 1):
                                #msgImagePronoun = "all images"

                            #else:            QMessageBox.information(self, "%s - %s" % (PROGRAM_NAME, _("information")), _("control"))

                                #msgImagePronoun = "next image"

                            #msgImageUrl = "\n\n" + "\n".join([toUnicode(urlItem.toString()) for urlItem in event.mimeData().urls()])
                            #urlReply = QMessageBox.question(self, _("%s - add data") % PROGRAM_NAME, _("add %s as %s?%s") % (msgImagePronoun, ontologyUrl, msgImageUrl), QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

                            #if urlReply == QMessageBox.Yes:
                            downloadTo = "%s%s/" % (NEPOOGLE_DOWNLOADS_PATH, uri.replace("nepomuk:/res/", ""))
                            if not os.path.exists(downloadTo):
                                os.makedirs(downloadTo)

                            #downloadTo = downloadTo + urlDecode(os.path.basename(url))
                            url = toUtf8(url)
                            downloadTo = downloadTo + md5.new(url).hexdigest() + os.path.splitext(url)[1].lower()
                            if downloadFile(url, downloadTo):
                                # Remote resource creation to store the original url.
                                urlRemoteResource = Nepomuk2.Resource(QUrl(url), NOC("nfo:WebDataObject", True))
                                urlRemoteResource.addType(NOC("nfo:RemoteDataObject", True))

                                # Local resource creation to store where file is copied.
                                urlLocalResource = Nepomuk2.Resource(QUrl("file://" + downloadTo), NOC(ONTOLOGY_TYPE_IMAGE, True))
                                urlLocalResource.addProperty(NOC(ONTOLOGY_TITLE, True), toVariant(os.path.basename(url)))
                                urlLocalResource.addProperty(NOC(ONTOLOGY_COPIED_FROM, True), toVariant(urlRemoteResource))

                                # Assigning local resource to the resource.
                                uriResource = Nepomuk2.Resource(uri)
                                uriResource.addProperty(NOC(ontologyUrl, True), toVariant(urlLocalResource))
                                mustRefresh = SLEEP_AFTER_UPDATE

                            else:
                                KMessageBox.error(None, _("Download failed."))

                        else:
                            urlReply = QMessageBox.question(self, '%s - add resource' % PROGRAM_NAME, "Add \"%s\" as \"%s\"?" % (url, ONTOLOGY_LINK), QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                            if (urlReply == QMessageBox.Yes):
                                # This code has really low performance so don't use it.
                                #urlResource = Nepomuk.Resource()
                                #urlResource.addType(NOC("nfo:Website", True))
                                #urlResource.setProperty(NOC("nie:url", True), toVariant(QUrl(url)))
                                #uriResource.addProperty(NOC(ontologyUrl, True), toVariant(urlResource.uri()))
                                urlResource = Nepomuk2.Resource(QUrl(url), NOC("nfo:RemoteDataObject", True))
                                urlResource.addType(NOC("nfo:Website", True))
                                uriResource = Nepomuk2.Resource(uri)
                                uriResource.addProperty(NOC(ONTOLOGY_LINK, True), toVariant(urlResource))
                                mustRefresh = SLEEP_AFTER_UPDATE

                else:
                    # Not image, url or image_url.
                    if (self.model == None):
                        return False

                    if INTERNAL_RESOURCE:
                        resource = cResource(url)

                    else:
                        resource = Nepomuk2.Resource(url)

                    resourceMainType = NOCR(resource.type())
                    resourceGenericLabel = resource.genericLabel()

                    if (dropType == "resource"):
                        query = 'SELECT DISTINCT ?r\n' \
                                'WHERE {\n' \
                                    '\t?r rdfs:range %s . FILTER(REGEX(?r, "nao#", "i") || REGEX(?r, "nco#", "i") || REGEX(?r, "nmm#", "i")) . \n' \
                                '}\n' \
                                % (resourceMainType)

                    else:
                        query = 'SELECT DISTINCT ?r\n' \
                                'WHERE {\n' \
                                    '\t?r rdfs:domain %s .\n' \
                                '}\n' \
                                % (resourceMainType)

                    values = [[ONTOLOGY_LINK, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_LINK)["label"], ONTOLOGY_LINK)], \
                                [ONTOLOGY_SUBJECT, "%s (%s)" % (self.ontologyInfo(ONTOLOGY_SUBJECT)["label"], ONTOLOGY_SUBJECT)]]
                    queryResultSet = self.model.executeQuery(query, SOPRANO_QUERY_LANGUAGE)
                    if queryResultSet.isValid():
                        while queryResultSet.next():
                            ontology = NOCR(toUnicode(queryResultSet["r"].toString()))
                            if (not ontology in (ONTOLOGY_LINK, ONTOLOGY_SUBJECT)):
                                values += [[ontology, "%s (%s)" % (self.ontologyInfo(ontology)["label"], ontology)]]

                    if (values != []):
                        values = sorted(values, key=lambda item: item[1].lower())
                        parameters = []
                        for value in values:
                            if (value[0] == self.lastOntologySelected):
                                status = "on"

                            else:
                                status = "off"

                            parameters += [value[0], value[1], status]

                        ontologyResource, labelResource = dialogList(parameters, _("Select an ontology:"))
                        if not ontologyResource:
                            continue

                        #resourceReply = QMessageBox.question(self, '%s - add resource' % PROGRAM_NAME, "Add \"%s\" as \"%s\"?" % (resourceGenericLabel, ontologyResource), QMessageBox.Yes | QMessageBox.No, QMessageBox.No)
                        resourceReply = QMessageBox.Yes
                        if (resourceReply == QMessageBox.Yes):
                            self.setAppCursor(Qt.BusyCursor)
                            for uri in uris:
                                print("%s: property %s added" % (uri, ontologyResource))
                                #print("Adding property: %s, %s, %s" % (uri, ontologyResource, url))
                                updateResource = Nepomuk2.Resource(uri)
                                if (dbOperation == "add"):
                                    updateResource.addProperty(NOC(ontologyResource, True), toVariant(url))

                                elif (dbOperation == "remove"):
                                    updateResource.removeProperty(NOC(ontologyResource, True), toVariant(url))

                            self.setAppCursor()
                            if (len(uris) == 1):
                                mustRefresh = SLEEP_AFTER_UPDATE

                            else:
                                mustRefresh = SLEEP_MESSAGE_BOX

                            self.lastOntologySelected = ontologyResource

                    else:
                        QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("error")), _("Sorry, I don't know what to do with this resource and custom ontologies are not supported yet."))

        elif (event.mimeData().hasText()):
            text = toUnicode(event.mimeData().text())
            if not text:
                return False

            self.addProperty(uri, "", text)

        if (mustRefresh > SLEEP_NO_SLEEP):
            time.sleep(mustRefresh)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.queryMethod = "refresh"
            self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                % self.iconProcessIdle)

        elif (mustRefresh == SLEEP_MESSAGE_BOX):
            QMessageBox.information(self, "%s - %s" % (PROGRAM_NAME, _("Information")), _("Process finished."))


    def goBackward(self):
        #print("Go backward")
        refresh = False
        searchText = self.leSearch.text()
        if self.queriesIndex >= 0 and searchText != self.cache[self.queriesIndex].searchString:
            refresh = True

        else:
            if (self.queriesIndex > 0):
                self.queriesIndex -= 1
                refresh = True

        if refresh:
            self.setAppCursor(Qt.BusyCursor)
            searchString = self.cache[self.queriesIndex].searchString
            #if searchString[:3] == "e1 ":
            #    searchString = searchString[3:]

            self.leSearch.setText(searchString)
            self.setPendingQuery(False)

            if ((self.queriesIndex - 1 >= 0) and (self.cache[self.queriesIndex - 1].navegable)):
                self.navigationData = self.cache[self.queriesIndex - 1].data

            elif ((self.queriesIndex >= 0) and (self.cache[self.queriesIndex].navegable)):
                self.navigationData = self.cache[self.queriesIndex].data

            else:
                self.navigationData = []

            html = self.cache[self.queriesIndex].formatAsHtml()
            if (self.queriesIndex >= 0):
                if ((self.cache[self.queriesIndex-1].navegable) or (self.cache[self.queriesIndex].navegable)):
                    dataIndex = lindex(self.navigationData, searchString)
                    if (dataIndex != None):
                        dataLength = len(self.navigationData)
                        html = html.replace("<navigator />", self.cache[self.queriesIndex].htmlRenderLink("navigator", dataIndex, dataLength))

            self.wvOutput.setHtml(html)

            self.setAppCursor()
            self.leSearch.readOnly = False
            self.repaint()


    def goForward(self):
        #print("Go forward")
        if (self.queriesIndex < (len(self.cache) - 1)):
            self.queriesIndex += 1
            self.setAppCursor(Qt.BusyCursor)
            searchString = self.cache[self.queriesIndex].searchString
            #if searchString[:3] == "e1 ":
            #    searchString = searchString[3:]

            self.leSearch.setText(searchString)
            self.setPendingQuery(False)

            if ((self.queriesIndex - 1 >= 0) and (self.cache[self.queriesIndex - 1].navegable)):
                self.navigationData = self.cache[self.queriesIndex - 1].data

            elif ((self.queriesIndex >= 0) and (self.cache[self.queriesIndex].navegable)):
                self.navigationData = self.cache[self.queriesIndex].data

            else:
                self.navigationData = []

            html = self.cache[self.queriesIndex].formatAsHtml()
            if (self.queriesIndex >= 0):
                if ((self.cache[self.queriesIndex-1].navegable) or (self.cache[self.queriesIndex].navegable)):
                    dataIndex = lindex(self.navigationData, searchString)
                    if (dataIndex != None):
                        dataLength = len(self.navigationData)
                        html = html.replace("<navigator />", self.cache[self.queriesIndex].htmlRenderLink("navigator", dataIndex, dataLength))

            self.wvOutput.setHtml(html)

            self.setAppCursor()
            self.leSearch.readOnly = False
            self.repaint()


    def refreshStopAction(self):
        if (self.threadModeEnabled and self.pendingQuery):
            #TODO: implement this.
            self.threadQuery.terminate()
            self.setPendingQuery(False)
            set.wvOutput.setHtml(_("Cancel on user request."))

        else:
            if (self.queriesIndex >= 0):
                self.setAppCursor(Qt.BusyCursor)
                self.setPendingQuery(True)
                self.queryMethod = "refresh"
                self.wvOutput.setHtml('<html><body><h3>Searching... <img src="file://%s"></h3></body></html>' \
                    % self.iconProcessIdle)


    def editSparql(self):
        searchString = toUnicode(self.leSearch.text().trimmed().toUtf8())
        sparql = None
        if (searchString[:3] in ("-m0 ", "-m1 ")):
            searchString = searchString[3:]

        elif (searchString[:7].lower() == "sparql:"):
            sparql = searchString[7:]

        else:
            pass

        if not sparql:
            sparql = self.sparql.buildQuery(searchString).strip()

        newSparql = dialogTextInputBox("Edit SPARQL:", sparql, "sparql")

        if (newSparql and (newSparql != sparql)):
            self.leSearch.setText("SPARQL:" + newSparql)
            self.setAppCursor(Qt.BusyCursor)
            self.setPendingQuery(True)
            self.wvOutput.setHtml('<html><body><h3>Reading... <img src="file://%s"></h3></body></html>' \
                                    % self.iconProcessIdle)
            if forceExec:
                self.execQuery()
                self.setPendingQuery(False)


    def showHelp(self):
        self.leSearch.setText("--help")
        self.setPendingQuery(False)
        self.wvOutput.setHtml(self.buildHelp(self.sparql))
        self.repaint()


    def buildHelp(self, oSparqlBuilder):
        htmlTableHeader = "<table style=\"text-align:left; width: 100%%;\" " \
                            "border=\"%(border)s\" cellpadding=\"%(cellpadding)s\" cellspacing=\"0\">" \
                            "<tbody>\n"
        htmlTableFooter = "</tbody></table>\n"

        commands = '<p><b>Commands</b>:\n<ul>\n'
        for command in oSparqlBuilder.commands:
            if (command[1][0].find("%s") >= 0):
                commands += '<li>%(command)s:"text"</a></li>\n' % {"command": command[0]}

            elif (command[0] == "--sort"):
                commands += '<li>%(command)s:"[+|-]shortontology[,[+|-]shortontology]..."</a></li>\n' % {"command": command[0]}

            else:
                commands += '<li><a href="command:/%(command)s">%(command)s</a></li>\n' % {"command": command[0]}

        commands += '</ul></p>\n'

        shortcuts = '<p><b>Shortcuts</b>:<ul>\n' + htmlTableHeader \
                        % {'border': 0, 'cellpadding': 0}
        for shortcut in oSparqlBuilder.shortcuts:
            info = ''
            try:
                ontHelp = shortcut[3]

            except:
                ontHelp = ""

            fmtOntology = shortcut[0]
            if fmtOntology.find('%') >= 0:
                fmtOntology = fmtOntology.replace('%', '')
                info += ' (using percent encoding)'

            elif fmtOntology.find('!') >= 0:
                fmtOntology = fmtOntology.replace('!', '')
                info += ' (supports duplicated properties)'

            if fmtOntology.find('_') >= 0:
                fmtOntology = fmtOntology.replace('_', '')
                info += ' (using FILTER NOT EXISTS to negate)'

            shortcuts += '<tr><td width=150px><b>%(abr)s</b>,<b>%(shortcut)s</b>:</td>' \
                            '<td width=150px>%(help)s</td>' \
                            '<td><em>%(ontology)s</em>%(info)s</td></tr>\n' \
                        % {'abr': shortcut[2], 'shortcut': shortcut[1], 'help': ontHelp, 'ontology': fmtOntology, 'info': info}

        shortcuts += htmlTableFooter + '</ul></p>\n'

        remarks = "<p><b>Remarks</b>:<br \>\n" \
                    "<ul>\n" \
                    "<li>This program needs to work <b>KDE 4.10</b>, <a href=\"http://quickgit.kde.org/?p=scratch%2Fsedwards%2Fpykde4nepomuk2.git\">Python Nepomuk2 Bindings</a> installed and Nepomuk running." \
                    "<li>Query syntax is inspired in Google's search syntax.</li>\n" \
                    "<li>You can use regular expressions searching strings.</li>\n" \
                    "<li>Nepoogle uses own query engine but Nepomuk query parser it's available using prefix e0.</li>\n" \
                    "<li>Be cautious, certain ontologies combinations in a same query may offer 0 results.</li>\n" \
                    "<li>Resorces can be edited but that functionality it's an experimental feature in alpha stage.</li>\n" \
                    "</ul></p>\n"

        commandsList = ''
        for command in oSparqlBuilder.commands:
            if commandsList != '':
                commandsList += ' | ' + command[0]

            else:
                commandsList += command[0]

        shortcutsList = ''
        for shortcut in oSparqlBuilder.shortcuts:
            if shortcutsList != '':
                shortcutsList += ' | ' + shortcut[1]

            else:
                shortcutsList += shortcut[1]

        syntax = "<p><b>The query syntax is</b>:<ul>\n" \
                    "<em>query</em> :== e0 querystring<sup> 1)</sup><br />\n"\
                    "<br />\n" \
                    "<em>query</em> :== SPARQL: valid sparql query <sup>2)</sup><br />\n"\
                    "<br />\n" \
                    "<em>query</em> :== [e1] item [[logop] item]... | command | uri<br />\n"\
                    "<br />\n" \
                    "<em>op</em> :== + | - | compop<br />\n" \
                    "<em>logop</em> :== and | or<br />\n" \
                    "<em>compop</em> :==  = | < | <= | > | >=<br />\n" \
                    "<br />\n" \
                    "<em>item</em> :== [ontology:][op]text | &lt;ontology&gt;&lt;op&gt;&lt;text&gt;<br />\n" \
                    "<br />\n" \
                    "<em>ontology</em> :== [ontitem=]ontitem[relation[ontitem=]ontitem]]...<br />\n" \
                    "<em>ontitem</em> :== shortcutontology | shortontology | fullontology<br />\n" \
                    "<em>relation</em> :== -> | <-<br />\n" \
                    "<em>shortcutontology</em> :== %(shortcuts)s<br />\n" \
                    "<em>shortontology</em> :== prefix:name<br />\n" \
                    "<em>fullontology</em> :== &lt;http://fullurl&gt;<br />\n" \
                    "<br />\n" \
                    "<em>text</em> :== date | number | string | time<br />\n" \
                    "<em>date</em> :== yyyy-mm-dd | month | day | year<br />\n" \
                    "<em>month</em> :== 1..12[m]<br />\n" \
                    "<em>day</em> :== 13..31 | 1..31d<br />\n" \
                    "<em>year</em> :== 32..9999 | 1..9999y<br />\n" \
                    "<em>number</em> :== posnumber | negnumber | fraction<br />\n" \
                    "<em>posnumber</em> :== 0..9<br />\n" \
                    "<em>negnumber</em> :== compop-0..9<br />\n" \
                    "<em>fraction</em> :== posnumber/posnumber | negnumber/posnumber<br />\n" \
                    "<em>string</em> :== chars | \"chars\" | 'chars'<br />\n" \
                    "<em>chars</em> :== any number of utf-8 characters<br />\n" \
                    "<em>time</em> :== hh:mm:ss | hour | minute | seconds<br />\n" \
                    "<em>hour</em> :== 1..24[h]<br />\n" \
                    "<em>minute</em> :== 25..59 | 1..59m<br />\n" \
                    "<em>seconds</em> :== 1..59s<br />\n" \
                    "<br />\n" \
                    "<em>command</em> :== instruction[:string]<br />\n" \
                    "<em>instruction</em> :== %(instructions)s<br />\n" \
                    "<br />\n" \
                    "Some <em>shorcutontologies</em> have special values:<br />\n" \
                    "-flash: [ %(flash)s ]<br />\n" \
                    "-indexinglevel: [ %(indexinglevel)s ]<br />\n" \
                    "-meteringmode: [ %(meteringmode)s ]<br />\n" \
                    "-saturation: [ %(saturation)s ]<br />\n" \
                    "-sharpness: [ %(sharpness)s ]<br />\n" \
                    "-whitebalance: [ %(whitebalance)s ]<br />\n" \
                    "<br />\n" \
                    "<sup>1)</sup> e0 uses <a href=\"http://api.kde.org/4.10-api/kdelibs-apidocs/nepomuk/html/classNepomuk_1_1Query_1_1QueryParser.html\">Nepomuk::Query::QueryParser()</a> so query syntax it's different.<br />" \
                    "<sup>2)</sup> column ?r is required to display results.<br />" \
                    "</ul>" \
                    "</p>\n" \
                    % {'shortcuts': shortcutsList, 'instructions': commandsList, \
                        'flash': " | ".join(NEXIF_FLASH), \
                        'indexinglevel': " | ".join(KEXT_INDEXING_LEVEL), \
                        'meteringmode': " | ".join(NEXIF_METERING_MODE), \
                        'saturation': " | ".join(NEXIF_SATURATION), \
                        'sharpness': " | ".join(NEXIF_SHARPNESS), \
                        'whitebalance': " | ".join(NEXIF_WHITE_BALANCE) \
                        }

        examples = "<p><b>Examples</b>:\n" \
                    + htmlTableHeader % {'border': 1, 'cellpadding': 2} + \
                    "<tr><td><b>query</b></td>\n" \
                        "<td><b>result</b></td></tr>\n" \
                    "<tr><td><em>movie</em></td>\n" \
                        "<td>contains word 'movie'</td></tr>\n" \
                    "<tr><td><em>-movie</em></td>\n" \
                        "<td>not contains word 'movie' (caution, this query could be very slow in a big database)</td></tr>\n" \
                    "<tr><td><em>hastag:-dorama and ('Takeuchi' or 'Hiroshi')</em></td>\n" \
                        "<td>not tagged as 'dorama' and contains 'Takeuchi' or 'Hiroshi'</td></tr>\n" \
                    "<tr><td><em>movie or actor:'takeuchi yuuko'</em></td>\n" \
                        "<td>contains word movie or one of the actors is 'takeuchi yuuko'</td></tr>\n" \
                    "<tr><td><em>hasTag:+movie rating:>=5</em></td>\n" \
                        "<td>tagged exactly 'movie' and rating >= 5</td></tr>\n" \
                    "<tr><td><em>url:\"^file:///media\" mimetype:image mimetype:-image/jpeg</em></td>\n" \
                        "<td>all image files, except jpegs, located in /media</td></tr>\n" \
                    "<tr><td><em>mimetype:png ((height:1200 width:1600) or height:>1900)</em></td>\n" \
                        "<td>all pngs with a resolution of 1600x1200 or with a height greater than 1900</td></tr>\n" \
                    "<tr><td><em>genre:drama actor:+'Yeong-ae Lee' director:Park</em></td>\n" \
                        "<td>all drama resources with actress 'Yeong-ae Lee' and a director whose name contains 'Park'</td></tr>\n" \
                    "<tr><td><em>actor:'Zhang Ziyi' and actor:-'Bingbing Fan'</em></td>\n" \
                        "<td>all resources with actress 'Zhang Ziyi' but without actress 'Bingbing Fan'</td></tr>\n" \
                    "<tr><td><em>tvshow:Coupling season:2 (episode:4 or episode:5) --playlist</em></td>\n" \
                        "<td>episodes 4 and 5 of season 2 of Coupling displayed using playlist view</td></tr>\n" \
                    "<tr><td><em>--tags</em></td>\n" \
                        "<td>all tags</td></tr>\n" \
                    "<tr><td><em>albums: nmm:musicAlbum<-released:2012</em></td>\n" \
                        "<td>all albums released on 2012</td></tr>\n" \
                    "<tr><td><em>flash:yes whitebalance:auto nexif:exposureTime:1/60 nexif:fNumber:2.8 nexif:focalLength:>5.4</em></td>\n" \
                        "<td>photos with flash, automatic white balance, a exposure time of 1/60 s, a relative aperture of 2.8 mm and a focal length greather than 5.4 mm</td></tr>\n" \
                    "<tr><td><em>contacts: --sort:-nao:numericRating,nco:fullname</em></td>\n" \
                        "<td>all contacts sorted descending by rating and ascending by fullname</td></tr>\n" \
                    "<tr><td><em>album:\"25 Years The Chain\" --musicplayer</em></td>\n" \
                        "<td>album \"25 Years the Chain\" displayed using music player view</td></tr>\n" \
                    + htmlTableFooter + \
                    "</p>\n"

        output = "<html>\n  <head>\n"\
                    "<style type=\"text/css\">" \
                    "body {%(body_style)s}\n" \
                    "p {%(p_style)s}\n" \
                    "ul {%(ul_style)s}\n" \
                    "li {%(li_style)s}\n" \
                    "tr {%(tr_style)s}\n" \
                    "</style>\n" \
                    "<title>%(title)s</title>\n    " \
                    "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">" \
                    "\n  </head>\n<body>\n" \
                    "<p><h3>%(program)s's help</h3></p>\n" \
                    "<p><b>%(program)s</b> is a tool to query the <em>Nepomuk's database</em>. <b>%(program)s</b> does not search the file system but search previously indexed data by <em>Nepomuk</em>.</p>\n" \
                    "%(examples)s" \
                    "%(remarks)s" \
                    "%(commands)s" \
                    "%(shortcuts)s" \
                    "%(syntax)s" \
                    "For bugs, suggestions or wishes send a mail to kde@aynoa.net\n" \
                    "%(powered)s</body>\n</html>" \
                    % {'title': 'Querying Nepomuk', \
                        'error': sys.exc_info()[1], \
                        'program': os.path.basename(sys.argv[0]), \
                        'powered': PROGRAM_HTML_POWERED, \
                        'remarks': remarks, \
                        'syntax': syntax, \
                        'shortcuts': shortcuts, \
                        'commands': commands, \
                        'examples': examples, \
                        'body_style': "font-size:small", \
                        'p_style': "font-size:small", \
                        'ul_style': "font-size:small", \
                        'li_style': "font-size:small", \
                        'tr_style': "font-size:small;" \
                        }

        return output


    def ontologyInfo(self, ontology = "", model = None):
        if not model:
            model = self.model

        return ontologyInfo(ontology, model, True)


    def processMacros(self, searchString = ""):
        idx = searchString.find("--m:")
        if (idx < 0):
            return searchString

        items = searchString.split(":")
        macroId = items[1]
        try:
            filterValue = items[2]
            if not filterValue:
                raise Exception(_("An additional search string is required with a macro."))

        except:
            raise Exception(_("An additional search string is required with a macro."))

        idx = lindex(self.macros, macroId, 0)
        if (idx != None):
            searchString = searchString.replace("--m:%s:" % macroId, self.macros[idx][1])

        #if (searchString.find("--mnit:") >= 0):
            #searchString = searchString.replace("--mnit:", "--playlist genre:-instrumental performer:")

        #elif (searchString.find("--mnia:") >= 0):
            #searchString = searchString.replace("--mnia:", "--playlist genre:-instrumental nmm:musicAlbum->nmm:albumArtist->nco:fullname:")

        #elif (searchString.find("--mmar:") >= 0):
            #searchString = searchString.replace("--mmar:", "--musicplayer genre:-instrumental nmm:musicAlbum->nmm:albumArtist->nco:fullname:")

        #elif (searchString.find("--mmal:") >= 0):
            #searchString = searchString.replace("--mmal:", "--musicplayer genre:-instrumental album:")

        return searchString


    def runQuery(self, searchString = "", query = ""):
        #http://techbase.kde.org/Development/Tutorials/Python_introduction_to_signals_and_slots#Signals_and_slots_and_threading
        self.threadQuery = runSparqlQuery(self.model, searchString, query, False)
        self.threadQuery.start()
        QObject.connect(self.threadQuery, SIGNAL("SparqlExecuted"), self.getQueryData, Qt.QueuedConnection)
        self.threadQuery.execQuery()


    def getQueryData(self, searchString = None):
        if not searchString:
            # Invoqued by signal.
            self.resultData, self.resultStructure, self.resultTime = self.threadQuery.getResult()
            searchString = self.threadQuery.searchString

        oDataFormat = cDataFormat(searchString, self.model, self.screenWidth, None, self, cfgManager)
        if (('musicplayer' in self.sparql.externalParameters) or ('--musicplayer' in self.sparql.externalParameters)):
            output = oDataFormat.formatAsMusicPlayer('musicplayer', self.resultData, self.resultStructure, self.resultTime)
            if self.resizeMainWindowInMusicPlayerView:
                self.resize(800,500)

        elif (('playlist' in self.sparql.externalParameters) or ('--playlist' in self.sparql.externalParameters)):
            output = oDataFormat.formatAsHtmlPlaylist('playlist', self.resultData, self.resultStructure, self.resultTime)

        elif (('playmixed' in self.sparql.externalParameters) or ('--playmixed' in self.sparql.externalParameters)):
            output = oDataFormat.formatAsHtmlPlaylist('playmixed', self.resultData, self.resultStructure, self.resultTime)

        else:
            output = oDataFormat.formatAsHtml(self.resultData, self.resultStructure, self.resultTime)

        # Cache must be trunked in current position if query changed.
        if ((self.queriesIndex >= 0) and (self.queriesIndex + 1 < len(self.cache))):
            if self.cache[self.queriesIndex].searchString != searchString:
                self.cache = self.cache[:self.queriesIndex + 1]

        if (self.cache == []) or (self.cache[self.queriesIndex].searchString != searchString):
            self.cache += [oDataFormat]
            self.queriesIndex += 1

        else:
            self.cache[self.queriesIndex] = oDataFormat

        self.navigationData = self.cache[self.queriesIndex].data
        self.setAppCursor()

        self.setPendingQuery(False)
        self.queryMethod = None
        if (output != ""):
            if (self.queriesIndex >= 0):
                if ((self.cache[self.queriesIndex-1].navegable) or (self.cache[self.queriesIndex].navegable)):
                    dataIndex = lindex(self.navigationData, searchString)
                    if (dataIndex != None):
                        dataLength = len(self.navigationData)
                        output = output.replace("<navigator />", self.cache[self.queriesIndex].htmlRenderLink("navigator", dataIndex, dataLength))

            self.wvOutput.setHtml(output)

        self.setAppCursor()
        self.leSearch.readOnly = False
        self.repaint()

        ## Handle possible warnings.
        warningMsg = ""
        for warning in self.warningsList:
            if warningMsg:
                warningMsg += "\n\n"

            #if (warning[0] == "BUG001"):
                #warningMsg += "There is a know bug using negation without a shortcut.\n" \
                        #"Please notice that the results may be inaccurate.\n\n"
                #for i in range(1, len(warning)):
                    #warningMsg += "Change \"%s\" for something like \"title:%s\" to solve this issue.\n" \
                    #% (warning[i], warning[i])

            #else:
                #pass

        self.warningsList = []

        if warningMsg:
            QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("warning")), warningMsg)


    def execQuery(self, searchString = ''):
        self.leSearch.readOnly = True
        self.setAppCursor(Qt.BusyCursor)
        self.repaint()

        self.renderedRows = 0
        self.renderedCache = ''

        self.resultData = []
        self.resultStructure = []
        self.resultTime = None

        searchEngine = DEFAULT_ENGINE
        if (searchString == ''):
            searchString = toUnicode(self.leSearch.text().trimmed().toUtf8())

        elif (searchString == None):
            searchString = ""

        output = ""

        #if True:
        try:
            #if not DO_NOT_USE_NEPOMUK and self.clearResourceManagerCache:
            #    Nepomuk2.ResourceManager.instance().clearCache()

            if self.sparqlBuilderV1:
                self.sparql = cSparqlBuilder()

            else:
                self.sparql = cSparqlBuilder2(self.model)

            threadModeEnabled = self.threadModeEnabled
            if ((searchString[:10] == "<nepomuk:/") and (searchString[-1] == ">")):
                searchString = searchString[1:-1]

            if (searchString[:9] == 'nepomuk:/'):
                threadModeEnabled = False
                cachedData = None
                oDataFormat = None
                self.currUri = searchString
                if not self.queryMethod in ("manual", "refresh"):
                    cachedData = lvalue(self.cacheRendered, searchString, 0, 1)

                if (cachedData == None):
                    oDataFormat = cDataFormat(searchString, self.model, self.screenWidth, None, self, cfgManager)
                    output = oDataFormat.formatResourceInfo(searchString, self.sparql.shortcuts, ontologyTypes)

                else:
                    output = cachedData

                if (self.queryMethod == "navbutton"):
                    if (oDataFormat == None):
                        oDataFormat = cDataFormat(searchString, self.model, self.screenWidth, output, self, cfgManager)

                    self.cache[self.queriesIndex] = oDataFormat

                elif (self.queryMethod == "refresh"):
                    oDataFormat = cDataFormat(searchString, self.model, self.screenWidth, None, self, cfgManager)
                    output = oDataFormat.formatResourceInfo(searchString, self.sparql.shortcuts, ontologyTypes)
                    self.cache[self.queriesIndex] = oDataFormat

                elif (self.queryMethod == "manual"):
                    # Cache must be trunked in current position if query changed.
                    if ((self.queriesIndex >= 0) and (self.queriesIndex < len(self.cache))):
                        if (self.cache[self.queriesIndex].searchString != searchString):
                            self.cache = self.cache[:self.queriesIndex + 1]

                    if (self.cache == []) or (self.cache[self.queriesIndex].searchString != searchString):
                        self.cache += [oDataFormat]
                        self.queriesIndex += 1

                    else:
                        self.cache[self.queriesIndex] = oDataFormat

                    self.navigationData = []

                else:
                    # Cache must be trunked in current position if query changed.
                    self.queriesIndex += 1
                    if ((self.queriesIndex >= 0) and (self.queriesIndex < len(self.cache))):
                        if (self.cache[self.queriesIndex].searchString != searchString):
                            self.cache = self.cache[:self.queriesIndex]

                    if (oDataFormat == None):
                        oDataFormat = cDataFormat(searchString, self.model, self.screenWidth, output, self, cfgManager)

                    self.cache += [oDataFormat]

                if (cachedData == None):
                    i = lindex(self.cacheRendered, searchString, 0)
                    if i == None:
                        self.cacheRendered += [[searchString, output.replace("<cached />", " (cached)")]]

                    else:
                        self.cacheRendered[i][1] = output.replace("<cached />", " (cached)")

            elif (searchString[:7].strip().upper() == "SPARQL:"):
                self.lastSPARQLQuery = searchString.strip()[7:]
                self.sparql.stdoutQuery = (self.verboseMode and sys.stdout.isatty())
                self.setAppCursor(Qt.BusyCursor)
                if threadModeEnabled:
                    self.runQuery(searchString, self.lastSPARQLQuery)

                else:
                    self.resultData, self.resultStructure, self.resultTime = self.sparql.executeQuery(self.lastSPARQLQuery)

                self.warningsList = self.sparql.warningsList
                self.sparql.warningsList = []

                if not threadModeEnabled:
                    self.getQueryData(searchString)


            elif (searchString != ''):
                self.currUri = None
                searchString = self.processMacros(searchString)
                if searchString[:3].lower() in ('e0 ', 'e1 '):
                    searchEngine = int(searchString[1:2])

                else:
                    searchEngine = DEFAULT_ENGINE
                    searchString = "e%d %s" % (searchEngine, searchString)

                externalParameters = []

                # Very dirty hack to force commands to use searchEngine 1.
                if (searchEngine != 1):
                    tmpSearchString = searchString[3:].strip()
                    if ((len(tmpSearchString.split(" ")) == 1) and (tmpSearchString[:2] == "--")):
                        searchEngine = 1
                # Very dirty hack to force commands to use searchEngine 1.

                if (searchEngine == 0):
                    processedSearchString = searchString[3:]
                    if processedSearchString.find("--help") >= 0:
                        self.execQuery("e1 " + processedSearchString)
                        return True

                    oNQP = Nepomuk2.Query.QueryParser()
                    for command in ["--musicplayer", "--playlist", "--playmixed", "--sort"]:
                        if processedSearchString.find(command) >= 0:
                            externalParameters += [command]
                            processedSearchString = processedSearchString.replace(command, "")

                    query = toUnicode(oNQP.parse(processedSearchString).toSparqlQuery())
                    oNQP = None
                    readableQuery = toUtf8(query.replace("select distinct ", "SELECT DISTINCT ").replace(" where ", "\nWHERE ").replace("{", "{\n").replace("}", "\n}").replace("} .", "} .\n").replace("} UNION {", " } UNION {").replace(". ?", ".\n ?").replace("\n ?", "\n  ?").replace("\n} .", "\n } .").replace("} .\n  ?", "} .\n ?"))
                    if (self.verboseMode and sys.stdout.isatty()):
                        # Improve a little bit readability.
                        print(readableQuery)

                    #query = hackQueryParser(query, 'e0')
                    self.sparql.externalParameters += externalParameters
                    self.setAppCursor(Qt.BusyCursor)
                    if threadModeEnabled:
                        self.runQuery(searchString, query)

                    else:
                        self.resultData, self.resultStructure, self.resultTime = self.sparql.executeQuery(query)

                    self.lastSPARQLQuery = readableQuery

                else:
                    self.sparql.stdoutQuery = (self.verboseMode and sys.stdout.isatty())
                    if self.sparqlBuilderV1:
                        self.sparql.columns = '?x0 AS ?id ' + self.sparql.columns

                    self.sparql.externalParameters += externalParameters
                    self.setAppCursor(Qt.BusyCursor)
                    if threadModeEnabled:
                        self.runQuery(searchString, self.sparql.buildQuery(searchString[3:]))

                    else:
                        self.resultData, self.resultStructure, self.resultTime = self.sparql.executeQuery(self.sparql.buildQuery(searchString[3:]))

                    self.lastSPARQLQuery = self.sparql.lastSPARQLQuery
                    self.warningsList = self.sparql.warningsList
                    self.sparql.warningsList = []

                if not threadModeEnabled:
                    self.getQueryData(searchString[3:])

            else:
                raise Exception(_("Please, type something."))

        #try:
        #    pass

        except:
            msgError = "%s" % sys.exc_info()[1]
            if msgError == 'help':
                output = self.buildHelp(self.sparql)

            elif (msgError == "notindexed"):
                output = "<html>\n  <head>\n    <title>%(title)s</title>\n    " \
                            "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">" \
                            "\n  </head>\n<body><b>error:</b> %(error)s" \
                            "%(powered)s</body>\n</html>" \
                            % {'title': 'Querying Nepomuk', \
                                'error': 'This command works only in console mode.', \
                                'powered': PROGRAM_HTML_POWERED \
                                }

            elif msgError == "newcontact":
                self.linkClicked(QUrl("addresource:/nco:Contact"))

            elif msgError == 'quit':
                quit()

            else:
                output = "<html>\n  <head>\n    <title>%(title)s</title>\n    " \
                            "<meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\">" \
                            "\n  </head>\n<body><b>error:</b> %(error)s" \
                            "%(powered)s</body>\n</html>" \
                            % {'title': 'Querying Nepomuk', \
                                'error': sys.exc_info()[1], \
                                'powered': PROGRAM_HTML_POWERED \
                                }


        if not threadModeEnabled:
            self.setPendingQuery(False)
            self.queryMethod = None
            if (output != ""):
                if (self.queriesIndex >= 0):
                    if ((self.cache[self.queriesIndex-1].navegable) or (self.cache[self.queriesIndex].navegable)):
                        dataIndex = lindex(self.navigationData, searchString)
                        if (dataIndex != None):
                            dataLength = len(self.navigationData)
                            output = output.replace("<navigator />", self.cache[self.queriesIndex].htmlRenderLink("navigator", dataIndex, dataLength))

                self.wvOutput.setHtml(output)

            self.setAppCursor()
            self.leSearch.readOnly = False
            self.repaint()

            # Handle possible warnings.
            warningMsg = ""
            for warning in self.warningsList:
                if warningMsg != "":
                    warningMsg += "\n\n"

                #if warning[0] == "BUG001":
                    #warningMsg += "There is a know bug using negation without a shortcut.\n" \
                            #"Please notice that the results may be inaccurate.\n\n"
                    #for i in range(1, len(warning)):
                        #warningMsg += "Change \"%s\" for something like \"title:%s\" to solve this issue.\n" \
                        #% (warning[i], warning[i])

                #else:
                    #pass

            self.warningsList = []

            if warningMsg:
                QMessageBox.warning(self, "%s - %s" % (PROGRAM_NAME, _("warning")), warningMsg)

            self.setAppCursor()


#
# cCfgManager class
#
class cCfgManager():

    def __init__(self):

        self.cfg = dict()

        self.cfg["General"] = dict()
        self.cfg["General"]['autoResize'] = [True, "bool"]
        self.cfg["General"]['clearResourceManagerCache'] = [True, "bool"]
        self.cfg["General"]['resizeMainWindowInMusicPlayerView'] = [True, "bool"]
        self.cfg["General"]['screenHeight'] = [600, "int"]
        self.cfg["General"]['screenWidth'] = [800, "int"]

        self.cfg["Display"] = dict()
        self.cfg["Display"]['columnsCount'] = [3, "int"]
        self.cfg["Display"]['coverFileNames'] = [['cover.png', 'Cover.png', 'cover.jpg', 'Cover.jpg'], "lst"]
        self.cfg["Display"]['enableImageViewer'] = [True, "bool"]
        self.cfg["Display"]['hiddenOntologiesInResults'] = [["kao", "rdfs:Resource"], "lst"]
        self.cfg["Display"]['hiddenOntologies'] = [["kext:unixFileGroup", "kext:unixFileMode", "kext:unixFileOwner", "nao:hasSubResource", "nao:userVisible"], "lst"]
        self.cfg["Display"]['hiddenOntologiesInverse'] = [["nao:hasSubResource"], "lst"]
        self.cfg["Display"]['ignoredRowMark'] = ['[#]', "str"]
        self.cfg["Display"]['maxPageNumber'] = [20, "int"]
        self.cfg["Display"]['ontologyMusicAlbumCover'] = ['nmm:artwork', "str"]
        self.cfg["Display"]['playlistShowWithOneElement'] = [True, "bool"]
        self.cfg["Display"]['playlistDescendingOrderByAlbumYear'] = [True, "bool"]
        self.cfg["Display"]['readOnlyOntologies'] = [["kext:indexingLevel", "nie:url", "rdf:type"], "lst"]
        self.cfg["Display"]['renderSize'] = [25, "int"]
        self.cfg["Display"]['skippedOntologiesInResourceIsA'] = [["nao:hasSubResource"], "lst"]
        self.cfg["Display"]['videojsEnabled'] = [False, "bool"]

        self.cfg["Macros"] = dict()
        #self.cfg["Macros"]['maa'] = ['--musicplayer genre:-instrumental nmm:musicAlbum->nmm:albumArtist->nco:fullname:', "str"]
        #self.cfg["Macros"]['mal'] = ['--musicplayer genre:-instrumental album:', "str"]
        #self.cfg["Macros"]['nia'] = ['--playlist genre:-instrumental nmm:musicAlbum->nmm:albumArtist->nco:fullname:', "str"]
        #self.cfg["Macros"]['nit'] = ['--playlist genre:-instrumental performer:', "str"]
        self.cfg["Macros"]['playalbum'] = ['--musicplayer genre:-instrumental album:', "str"]


    def loadCfg(self):
        oCP = configparser.RawConfigParser()
        oCP.read(NEPOOGLE_CONFIG_FILE)

        for group in self.cfg.iterkeys():
            if (group == "Macros"):
                self.cfg[group] = []
                for key in oCP.options(group):
                    self.cfg[group] += [[key, oCP.get(group, key)]]

            else:
                for key in self.cfg[group]:
                    try:
                        if (self.cfg[group][key][1] == "bool"):
                            value = oCP.getboolean(group, key)

                        elif (self.cfg[group][key][1] == "float"):
                            value = oCP.getfloat(group, key)

                        elif (self.cfg[group][key][1] == "int"):
                            value = oCP.getint(group, key)

                        elif (self.cfg[group][key][1] == "lst"):
                            #value = re.sub(r'\s', '', oCP.get(group, key)).split(',')
                            value = [item.strip() for item in oCP.get(group, key).split(',')]

                        else:
                            value = oCP.get(group, key)

                        self.cfg[group][key][0] = value

                    except:
                        pass

        #for group in self.cfg.iterkeys():
        #    print("[%s]" % group)
        #    for key in self.cfg[group]:
        #        print("%s = %s" % (key, self.cfg[group][key][0]))


    def saveCfg(self):
        oCP = configparser.ConfigParser()
        for group in sorted(self.cfg.iterkeys()):
            oCP.add_section(group)
            for key in self.cfg[group]:
                if (self.cfg[group][key][1] == "lst"):
                    oCP.set(group, key, ", ".join(self.cfg[group][key][0]))

                else:
                    oCP.set(group, key, self.cfg[group][key][0])

        with open(NEPOOGLE_CONFIG_FILE, 'wb') as configfile:
            oCP.write(configfile)


def hackQueryParser(query = '', hackLevel = 'e2'):

    if hackLevel.lower() == 'e2' and query.find("?v7 ") > 0:
        query = query.replace(' ?r <http://www.semanticdesktop.org/ontologies/2007/08/15/nao#userVisible> ?v1 . FILTER(?v1>0) .', '')
        query = query.replace(' UNION { ?r ', ' UNION { ?0 ')
        query = query.replace(' { ?r ', ' { SELECT ?r WHERE { { ?r <http://www.semanticdesktop.org/ontologies/2007/08/15/nao#userVisible> 1 . ?r ')
        query = query.replace(' UNION { ?0 ', ' UNION { ?r ')
        query = query.replace(' } .', '}}} .')
        query = query.replace('.}}} .}}} . }', '. }}} . }')

        # Removing ?_n_f_t_m_ex_ field to avoid duplicates in the result.
        query = "SELECT DISTINCT ?r " + query[query.find("where"):]
        query = query.replace('SELECT DISTINCT ?r where { { { ', 'SELECT DISTINCT ?r WHERE { { ')

    elif hackLevel.lower() == 'e0':
        # Removing ?_n_f_t_m_ex_ field to avoid duplicates in the result.
        query = "SELECT DISTINCT ?r " + query[query.find("where"):]

    return query


def buildHelp():
    print("%(name)s %(version)s (%(date)s)\n" \
              % {'name': PROGRAM_NAME, 'version': PROGRAM_VERSION_VERSION, 'date': PROGRAM_VERSION_DATE})

    print("Usage: %s [command ] [query]\n" \
          "\n" \
          "commands:\n" \
          "  --help                 -- Shows this help\n" \
          "  --notindexed:FULLPATH  -- Check for not indexed files in FULLPATH\n" \
          "  --pipe                 -- Only urls are printed to stdout\n"
          "  --gui[=MODE]           -- Mode: ON, OFF, force gui mode (defaults ON)\n" \
          "  --results[=MODE]       -- Mode: ON, OFF, displays results in console mode (defaults ON)\n" \
          "  --verbose[=MODE]       -- Mode: ON, PROFILE, OFF (defaults ON with --gui parameter)\n" \
          "\n" \
          "query:\n" \
          "  Query syntax documentation is available in the gui mode help\n" \
          % PROGRAM_NAME)


def findNotIndexed(url = None, recursiveMode = True, pipeMode = False, SPARQLBuilderV1 = False):
    if url == None or url == "":
        print(_("ERROR: a url is required."))
        return False

    try:
        url = toUnicode(url)
        if (url[0] == "\"" and url[-1] == "\""):
            url = url[1:-1]

        if recursiveMode:
            if not pipeMode:
                print(_("Finding all files in \"%s\" ..." % toUtf8(url)))

            resourcesCount, resources = findRecurseFiles(url)

        else:
            resourcesCount = 1
            resources = [url]

        if url[0] == '^':
            n3url = '^' + QUrl(url[1:]).toEncoded()

        else:
            n3url  = QUrl(url).toEncoded()

        n3url = toUnicode(n3url.replace('?', '%3f'))
        n3url = n3url.replace('(', '\\\(').replace(')', '\\\)')

        if SPARQLBuilderV1:
            visibilityFilter = cSparqlBuilder().visibilityFilter

        else:
            visibilityFilter = cSparqlBuilder2().visibilityFilter

        notIndexedCount = 0
        sparqlQuery = None
        recordsets = []
        for item in resources:
            item = unicode(item)
            if (sparqlQuery == None):
                if not pipeMode:
                    print(_("Finding all indexed files in \"%s\"..." % toUtf8(url)))

                #sparqlQuery = \
                    #"SELECT DISTINCT ?url\n" \
                    #"WHERE {\n"\
                        #" ?x0 %s\n" \
                        #" FILTER(\n" \
                            #"  (bif:exists ((\n" \
                            #"  SELECT *\n" \
                            #"  WHERE {\n" \
                                #"   { ?x0 nie:url ?x1 . FILTER(REGEX(?x1, \"^file://%s\"^^xsd:string, 'i')) } . \n" \
                            #"  }\n" \
                            #"  )))\n" \
                        #" )\n" \
                        #" OPTIONAL { ?x0 nie:url ?url . } . \n" \
                    #"}\n" % (visibilityFilter, n3url)

                sparqlQuery = \
                    "SELECT DISTINCT ?url\n" \
                    "WHERE {\n" \
                        "  ?r nie:url ?url . FILTER(REGEX(?url, \"^file://%s\"^^xsd:string, 'i')) . \n" \
                    "}\n" % (n3url)

                if DO_NOT_USE_NEPOMUK:
                    model = Soprano.Client.DBusModel('org.kde.NepomukStorage', '/org/soprano/Server/models/main')

                else:
                    model = Nepomuk2.ResourceManager.instance().mainModel()

                count = 0
                queryResultSet = model.executeQuery(sparqlQuery, Soprano.Query.QueryLanguageSparqlNoInference)
                if queryResultSet.isValid():
                    while queryResultSet.next():
                        url = toUnicode(queryResultSet["url"].toString().toUtf8())
                        if url[:7] == "file://":
                            url = url[7:]

                        recordsets += [url]
                        count += 1

            if os.path.isdir(item):
                if not pipeMode:
                    print(_("Checking \"%s\"..." % toUtf8(item)))

            else:
                if (lindex(recordsets, item) == None):
                    notIndexedCount += 1
                    if not pipeMode:
                        print(_("NOT Indexed: \"%s\"" % toUtf8(item)))

                    else:
                        print(toUtf8(item))

        if not pipeMode:
            print(_("%s not indexed files were located." % notIndexedCount))

    except KeyboardInterrupt:
        print  "\nOperation aborted by user...\n" \

    return True


def develFunction():
    # Whithout this nepomuk don't works.
    app = QCoreApplication(sys.argv)
    #quit()

    query = "SELECT * WHERE { ?r ?p ?v . } LIMIT 10"
    model = Nepomuk2.ResourceManager.instance().mainModel()

    #http://techbase.kde.org/Development/Tutorials/Python_introduction_to_signals_and_slots#Signals_and_slots_and_threading
    threadQuery = runSparqlQuery(model, "", query, False)
    threadQuery.start()
    QObject.connect(threadQuery, SIGNAL("SparqlExecuted"), threadQuery.printResults, Qt.QueuedConnection)
    threadQuery.execQuery()

    sys.exit(app.exec_())

    #resource = Nepomuk2.Resource(uri)
    #print("resource(nco:fullname): " + toUnicode(resource.property(NOC("nco:fullname")).toString()))
    #value = toUnicode(resource.property(ontology).toString())

    #print("updateResorce = Nepomuk2.SimpleResource()")
    #updateResource = Nepomuk2.SimpleResource(resource.uri())
    #updateResource.remove(ontology, toVariant(value))
    #updateResource.addProperty(ontology, toVariant(value + "1"))

    #print("graph = Nepomuk2.SimpleResourceGraph()")
    #graph = Nepomuk2.SimpleResourceGraph()
    #graph.insert(updateResource)
    #print("Resources count: %d" % graph.count())

    #print("graph.save()")
    #job = graph.save()
    #print("job.exec(): %s " % job.exec_())

    #if (job.error() != 0):
        #print("ERROR(%s): %s" % (job.error(), job.errorString()))

    ## Cleaning up to avoid a crash.
    #job = graph = updateResource = resource = None

    #print "finished."


def main(args):
    displayResults = None
    SPARQLBuilderV1 = False
    gui = not sys.stdout.isatty()
    displayTime = None
    pipeMode = False
    verboseMode = None
    parameters = toUnicode('')
    paramOption = ""
    for i in range(1, len(args)):
        parameter = toUnicode(args[i].strip())

        if parameter.lower() == '--help':
            buildHelp()
            quit()

        elif (parameter.lower() == '--devel'):
            develFunction()
            quit()

        elif parameter.lower()[:5] == '--gui':
            paramValue = parameter.lower()[5:]
            if paramValue == "" or paramValue == "=on":
                gui = True

            elif paramValue == "=off":
                gui = False

            else:
                print("ERROR: Unknown parameter \"%s\".\n" % parameter)
                buildHelp()
                quit()

            continue

        elif parameter.lower()[:9] == '--verbose':
            paramValue = parameter.lower()[9:]
            if paramValue == '':
                if verboseMode == None:
                    verboseMode = True

            elif paramValue == '=on':
                verboseMode = True

            elif paramValue == '=off':
                verboseMode = False

            elif paramValue == '=profile':
                verboseMode = False
                pipeMode = True
                displayTime = True

            else:
                print("ERROR: Unknown parameter \"%s\".\n" % parameter)
                buildHelp()
                quit()

            continue

        elif parameter.lower() == "--pipe":
            pipeMode = True
            continue

        elif parameter.lower() == "--v1":
            SPARQLBuilderV1 = True
            continue

        elif parameter.lower()[:9] == '--results':
            paramValue = parameter.lower()[9:]
            if paramValue == '':
                if verboseMode == None:
                    displayResults = True

            elif paramValue == '=on':
                displayResults = True

            elif paramValue == '=off':
                displayResults = False

            else:
                print("ERROR: Unknown parameter \"%s\".\n" % parameter)
                buildHelp()
                quit()

            continue

        #elif parameter.find(' ') >= 0:
            #j = parameter.rfind(':')
            #if j >= 0:
                #parameter = parameter[:j+1] + '"' + parameter[j+1:] + '"'

            #else:
                #parameter = '"' + parameter + '"'

        parameters += parameter + ' '

    if pipeMode:
        verboseMode = False
        gui = False

    searchString = parameters.strip()
    if gui:
        global cfgManager
        cfgManager = cCfgManager()

        if verboseMode == None:
            verboseMode = gui

        aboutData = KAboutData(PROGRAM_NAME, PROGRAM_NAME, ki18n(PROGRAM_NAME), PROGRAM_VERSION_VERSION,
                                ki18n("An alternate search engine for Nepomuk inspired in Google search syntax."),
                                KAboutData.License_GPL, ki18n("(C) 2011 %s" % PROGRAM_AUTHOR_NAME),
                                ki18n("A search engine for Nepomuk."),
                                "http://kde-apps.org/content/show.php/Nepoogle?content=145505",
                                PROGRAM_AUTHOR_EMAIL)
        KCmdLineArgs.init([sys.argv[0]], aboutData)

        #options = KCmdLineOptions()
        #options.add("help", ki18n("this help"))
        #options.add("gui", ki18n("force gui mode in console"))
        #options.add("stdout", ki18n("force stdout in console mode"))
        #options.add("nostdout", ki18n("force no stdout in gui mode"))
        #KCmdLineArgs.addCmdLineOptions(options)

        if not os.path.isfile(NEPOOGLE_CONFIG_FILE):
            cfgManager.saveCfg()

        else:
            cfgManager.loadCfg()

        app = KApplication()
        #app = QApplication(args)
        #nepoogleMain = NepoogleMain()
        #nepoogleMain.newWindow(searchString, verboseMode, QDesktopWidget().availableGeometry(-1), SPARQLBuilderV1)
        nepoogle = Nepoogle(None, searchString, verboseMode, QDesktopWidget().availableGeometry(-1), SPARQLBuilderV1)

        nepoogle.show()
        nepoogle.repaint()
        if searchString != '':
            nepoogle.execQuery()

        sys.exit(app.exec_())

    else:
        # Whithout this nepomuk don't works.
        app = QCoreApplication(sys.argv)

        if verboseMode == None:
            verboseMode == False

        searchEngine = DEFAULT_ENGINE
        if searchString[:3].lower() in ('e0 ', 'e1 '):
            searchEngine = int(searchString[1:2])

        if not pipeMode:
            output = "%(title)s\n" % {'title': 'Querying Nepomuk' }
            print(toUtf8(output))

        #if True:
        try:
            warningsList = []
            if SPARQLBuilderV1:
                oSparql = cSparqlBuilder()

            else:
                oSparql = cSparqlBuilder2()

            if searchString != '':

                # Very dirty hack to force commands to use searchEngine 1.
                if searchEngine != 1:
                    tmpSearchString = searchString.strip()
                    if ((len(tmpSearchString.split(" ")) == 1) and (tmpSearchString[:2] == "--")):
                        searchEngine = 1
                # Very dirty hack to force commands to use searchEngine 1.

                if searchEngine == 0:
                    oNQP = Nepomuk2.Query.QueryParser()
                    query = toUnicode(oNQP.parse(searchString[3:]).toSparqlQuery())
                    oNQP = None
                    if verboseMode:
                        # Improve a little bit readability.
                        print(toUtf8(query.replace(" where ", "\nwhere ").replace("{", "{\n").replace("}", "\n}").replace("} .", "} .\n").replace("} UNION {", " } UNION {").replace(". ?", ".\n ?").replace("\n ?", "\n  ?").replace("\n} .", "\n } .").replace("} .\n  ?", "} .\n ?")))

                    query = hackQueryParser(query, 'e0')
                    data, structure, time = oSparql.executeQuery(query)

                #elif searchEngine == 2:
                    #oNQP = Nepomuk2.Query.QueryParser()
                    #query = toUnicode(oNQP.parse(searchString[3:]).toSparqlQuery())
                    #oNQP = None
                    #query = hackQueryParser(query, 'e2')
                    #if verboseMode:
                        ## Improve a little bit readability.
                        #print(toUtf8(query.replace(" where ", "\nwhere ").replace("{", "{\n").replace("}", "\n}").replace("} .", "} .\n").replace("} UNION {", " } UNION {").replace(". ?", ".\n ?").replace("\n ?", "\n  ?").replace("\n} .", "\n } .").replace("} .\n  ?", "} .\n ?")))

                    #data, structure, time = oSparql.executeQuery(query)

                else:
                    oSparql.stdoutQuery = verboseMode
                    if SPARQLBuilderV1:
                        oSparql.columns = '?x0 AS ?id ' + oSparql.columns

                    data, structure, time = oSparql.executeQuery(oSparql.buildQuery(searchString))
                    warningsList =  oSparql.warningsList
                    oSparql.warningsList = []

                oSparql = None

                if displayResults in (None, True):
                    oDataFormat = cDataFormat(searchString)
                    oDataFormat.formatAsText(data, structure, time, pipeMode)

                if ((displayTime == None) and not pipeMode):
                    output = "\n%(records)s records found in %(seconds).4f seconds.\n" \
                                "--\n" \
                                "Powered by %(name)s %(version)s (%(date)s)" \
                                % {'records': len(data), \
                                    'seconds': time, \
                                    'name': PROGRAM_NAME, \
                                    'version': PROGRAM_VERSION_VERSION, \
                                    'date': PROGRAM_VERSION_DATE \
                                    }

                elif (displayTime):
                    output = "%(records)s records found in %(seconds).4f seconds." \
                                % {'records': len(data), 'seconds': time}

                else:
                    output = ""

                # Handle possible warnings.
                warningMsg = ""
                for warning in warningsList:
                    if warningMsg != "":
                        warningMsg += "\n\n"

                    if warning[0] == "BUG001":
                        warningMsg += "There is a know bug using negation without a shortcut.\n" \
                                "Please notice that the results may be inaccurate.\n\n"
                        for i in range(1, len(warning)):
                            warningMsg += "Change \"%s\" for something like \"title:%s\" to solve this issue.\n" \
                            % (warning[i], warning[i])

                    #else:
                        #pass

                warningsList = []

                if warningMsg != "":
                    output += '\n\nWARNING: ' + toUtf8(warningMsg)

            else:
                raise Exception(_("Please, type something."))

        #try:
        #    pass

        except KeyboardInterrupt:
            output = "\nOperation aborted by user...\n" \
                        "\n--\n" \
                        "Powered by %(name)s %(version)s (%(date)s)" \
                        % {'title': 'Querying Nepomuk', \
                            'error': sys.exc_info()[1], \
                            'name': PROGRAM_NAME, \
                            'version': PROGRAM_VERSION_VERSION, \
                            'date': PROGRAM_VERSION_DATE \
                            }

        except:
            msgError = "%s" % sys.exc_info()[1]
            output = ""
            if msgError == 'help':
                output = buildHelp()

            elif (msgError == "notindexed"):
                try:
                    path = oSparql.filters[0][0]

                except:
                    path = ""

                findNotIndexed(path, True, pipeMode, SPARQLBuilderV1) # Recursive, pimeMode.
                if not pipeMode:
                    output = "\n--\n" \
                                "Powered by %(name)s %(version)s (%(date)s)" \
                                % {'title': 'Querying Nepomuk', \
                                    'error': sys.exc_info()[1], \
                                    'name': PROGRAM_NAME, \
                                    'version': PROGRAM_VERSION_VERSION, \
                                    'date': PROGRAM_VERSION_DATE \
                                    }

            else:
                if not pipeMode:
                    output = "\nerror: %(error)s\n" \
                                "\n--\n" \
                                "Powered by %(name)s %(version)s (%(date)s)" \
                                % {'title': 'Querying Nepomuk', \
                                    'error': sys.exc_info()[1], \
                                    'name': PROGRAM_NAME, \
                                    'version': PROGRAM_VERSION_VERSION, \
                                    'date': PROGRAM_VERSION_DATE \
                                    }

                else:
                    output = "ERROR: %s" % sys.exc_info()[1]

        if output != "":
            print(toUtf8(output))


if __name__=="__main__":
    display = os.getenv("DISPLAY")
    if display == None:
        os.putenv("DISPLAY", ":0")

    main(sys.argv)
